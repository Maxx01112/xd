-- waiting for game
if not game.Loaded then
    game.Loaded:Wait()
end

-- services
local runService = game:GetService("RunService")
local players = game:GetService("Players")
local starterGui = game:GetService("StarterGui")
local tweenService = game:GetService("TweenService")
local userInputService = game:GetService("UserInputService")
local coreGui = game:GetService("CoreGui")
local replicatedStorage = game:GetService("ReplicatedStorage")
local virtualInputManager = game:GetService("VirtualInputManager")
local pathfindingService = game:GetService("PathfindingService")
local virtualUser = game:GetService("VirtualUser")
local httpService = game:GetService("HttpService")
local teleportService = game:GetService("TeleportService")
local lighting = game:GetService("Lighting")

-- player variables
local localPlayer = players.LocalPlayer
local character = localPlayer.Character
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
local humanoid = character:WaitForChild("Humanoid")
local mouse = localPlayer:GetMouse()
local controls = require(localPlayer.PlayerScripts.PlayerModule):GetControls()

-- attempt to make folders
local dictionary = {
    Hold = {
        CurrentBuilds = {},
        KeySystem = {}
    }
}
local function makeFolders(path, dictionary)
    local start = path == "workspace" and "" or path
    for name, dictionary in next, dictionary do
        makefolder(start .. "/" .. name)
        makeFolders(start .. "/" .. name, dictionary)
    end
end
makeFolders("workspace", dictionary)

-- script variables
local httpRequest = (syn and syn.request) or httprequest or request or (http and http.request)
local getasset = (syn and getsynasset) or getcustomasset

-- functions
local function jsonDecode(toString)
    return httpService:JSONDecode(toString)
end
local function jsonEncode(toJson, beautify)
    return httpService:JSONEncode(toJson)
end
local function sendWebhook(url, info)
    local response = httpRequest(
        {
            Url = url,
            Method = "POST",
            Headers = {
                ["Content-Type"] = "application/json"
            },
            Body = jsonEncode(info)
        }
    )
    return response
end
local function floorNumber(number, decimalPlaces)
	return math.round(number * 10 ^ decimalPlaces) * 10 ^ - decimalPlaces
end
local function deepClone(tab)
    local endTable = {}

    for index, value in next, tab do
        if type(value) == "table" then
            for index2, value2 in next, deepClone(value) do
                table.insert(endTable, value2) 
            end
        else
            table.insert(endTable, value)
        end
    end
    
    return endTable
end
local function tweenObject(object, time, data)
    local tween = tweenService:Create(object, TweenInfo.new(time, Enum.EasingStyle.Linear, Enum.EasingDirection.Out), data)
    tween:Play()
    return tween
end
local function noclip()
    for _, descendant in next, character:GetDescendants() do
        if descendant.ClassName:find("Part") and not descendant.ClassName:find("Particle") and descendant.CanCollide then
            descendant.CanCollide = false
        end
    end
end
local function timestampToString(time)
    local currentCount = time or 100

    local hours = 0
    local minutes = 0
    local seconds = 0

    local currentString = ""
    while currentCount >= 3600 do
        hours = hours + 1
        currentCount = currentCount - 3600
    end
    while currentCount >= 60 do
        minutes = minutes + 1
        currentCount = currentCount - 60
    end
    seconds = currentCount

    if hours > 0 then
        currentString = ("%sh %sm %ss"):format(tostring(hours), tostring(minutes), tostring(seconds))
    elseif minutes > 0 then
        currentString = ("%sm %ss"):format(tostring(minutes), tostring(seconds))
    else
        currentString = ("%ss"):format(tostring(seconds))
    end

    return currentString
end
local function beautifyMoney(cash)
    cash = type(cash) == "number" and cash or tonumber(cash)
    local formatted = math.floor(cash)
    while true do  
        formatted, count = string.gsub(formatted, "^(-?%d+)(%d%d%d)", '%1,%2')
        if count == 0 then
            break
        end
    end
    return formatted
end
local function reverseTable(table)
    for index = 1, math.floor(#table / 2) do
        local writeIndex = #table - index + 1
        table[index], table[writeIndex] = table[writeIndex], table[index]
    end
end
local oldToNumber = tonumber
local function tonumber(...)
    local args = {...}
    local final = {}

    for _, string in next, args do
        table.insert(final, oldToNumber(string))
    end

    return unpack(final)
end
local oldToString = tostring
local function tostring(...)
    local args = {...}
    local final = {}

    for _, string in next, args do
        table.insert(final, oldToString(string))
    end

    return unpack(final)
end
local function isMemberOf(origin, member)
    for _, descendant in next, origin:GetDescendants() do
        if member == descendant then
            return descendant
        end
    end
end
local function randomOneDecimalNumber()
    return tonumber("0.1" .. tostring(math.random(111111111, 999999999)))
end
local function fireConnections(instance, signal)
    firesignal(instance[signal])
end
local function dataRequire(module)
    return require(module)("", "")
end

-- edit tables
do
    setreadonly(Vector3, false)
    Vector3.inf = Vector3.new(9e9, 9e9, 9e9)
    setreadonly(Vector3, false)

    setreadonly(table, false)
    local oldSort = table.sort
    table.sort = function(theTable, theFunction)
        if #theTable < 2 then
            return
        end
        oldSort(theTable, theFunction)
    end
    setreadonly(table, false)
end

-- loops
do
    -- anti afk
    task.spawn(function()
        while task.wait(60) do
            virtualUser:CaptureController()
            virtualUser:ClickButton2(Vector2.new(0, 0))
        end
    end)

    -- random seed
    task.spawn(function()
        while task.wait(1) do
            math.randomseed(tick())
        end
    end)
end

-- requiring libraries
local libraries = {
    utilities = loadstring(httpRequest({
        Url = "https://bloxburger.eu/scripts/utility.lua",
        Method = "GET",
    }).Body)(),
    ui = loadstring(httpRequest({
        Url = "https://bloxburger.eu/scripts/ui.lua",
        Method = "GET",
    }).Body)(),
    flying = loadstring(httpRequest({
        Url = "https://bloxburger.eu/scripts/flying.lua",
        Method = "GET",
    }).Body)()
}
local discordData = loadstring(game:HttpGet("https://bloxburger.eu/scripts/data.lua"))()

-- bloxburger environment
local bloxburger = {
    ui = {
        pageLineColor = Color3.fromRGB(40, 40, 40),
        sectionLineColor = Color3.fromRGB(30, 30, 30)
    },
    jobs = {
        autoFarmEnabled = false,
        realisticMode = true
    }
}
setmetatable(bloxburger.jobs, {
    __index = function(table, index)
        bloxburger.jobs[index] = {}
        return bloxburger.jobs[index]
    end
})

-- create ui
local ui = libraries.ui:Window("Premium", Color3.fromRGB(0, 200, 0))

-- create pages
ui.pages = {
    autoBuild = ui:Page("Auto Build"),
    autoFarm = ui:Page("Auto Farm"),
    automatic = ui:Page("Automatic"),
    teleportation = ui:Page("Teleportation"),
    vehicle = ui:Page("Vehicle"),
    stats = ui:Page("Player Stats"),
    miscellaneous = ui:Page("Miscellaneous"),
    fun = ui:Page("Fun"),
    neighborhood = ui:Page("Neighborhood"),
    extra = ui:Page("Extra")
}

-- grabbing remotes
local remotes = {}
do
    for _, garbage in next, getgc() do
        if type(garbage) == "function" then
            local info = getinfo(garbage)

            if info.source:find("@") or not islclosure(garbage) then
                continue
            end
            if info.name ~= "remoteAdded" then
                continue
            end

            local hashRemotes = getupvalue(garbage, 1)
            local hashNames = getupvalue(getupvalue(garbage, 2), 1)

            for hash, name in next, hashNames do
                remotes[string.gsub(name, "F_", "")] = hashRemotes[hash]
            end

            break
        end
    end
end

local network = {}
do
    function network:FireServer(args)
        local args = table.clone(args)
        local remote = remotes[args.Type]
        args.Type = nil
        return remote:FireServer(args)
    end
    function network:InvokeServer(args)
        local args = table.clone(args)
        local remote = remotes[args.Type]
        args.Type = nil
        return remote:InvokeServer(args)
    end
end

local clientStats = replicatedStorage.Stats[localPlayer.Name]
local mainUi = localPlayer:WaitForChild("PlayerGui").MainGUI
local clientScripts = localPlayer:WaitForChild("PlayerScripts").Modules
local modules = {
    sideNotify = require(clientScripts.NotificationUI),
    notification = require(clientScripts._Utilities.GUIHandler),
    jobManager = require(clientScripts.JobHandler),
    wallService = require(replicatedStorage.Modules.WallService),
    objectService = require(replicatedStorage.Modules.ObjectService),
    materialData = require(replicatedStorage.Modules._Data.MaterialData),
    itemService = require(replicatedStorage.Modules.ItemService),
    plotService = require(replicatedStorage.Modules.PlotService),
    fenceService = require(replicatedStorage.Modules._Objects.FenceService),
    roofService = require(replicatedStorage.Modules.RoofService),
    groundService = require(replicatedStorage.Modules.GroundService),
    polygon = require(replicatedStorage.Modules._Utilities.Polygon),
    typeService = require(replicatedStorage.Modules.TypeService),
    resizeService = require(replicatedStorage.Modules.ResizeService),
    foodService = require(replicatedStorage.Modules.FoodService),
    equipmentService = require(replicatedStorage.Modules.EquipmentService),
    billService = require(replicatedStorage.Modules.BillService),
    staminaService = require(replicatedStorage.Modules.StaminaService),
    skillData = require(replicatedStorage.Modules._Data.SkillData),
    jobs = {}
}
local data = {items = replicatedStorage.Items} data = {
    foodList = dataRequire(data.items.Food),
    appliances = dataRequire(data.items.Appliances),
    jobData = {
        jobNames = {
            ["Pizza Delivery"] = "PizzaPlanetDelivery",
            ["Pizza Baker"] = "PizzaPlanetBaker",
            ["Mikes Mechanic"] = "MikesMechanic",
            ["Janitor"] = "CleanJanitor",
            ["Woodcutter"] = "LumberWoodcutter",
            ["Supermarket Stocker"] = "SupermarketStocker",
            ["Supermarket Cashier"] = "SupermarketCashier",
            ["Bloxy Burgers Cashier"] = "BloxyBurgersCashier",
            ["Stylez Hairdresser"] = "StylezHairdresser",
            ["Ice Cream Seller"] = "BensIceCreamSeller",
            ["Fisher"] = "HutFisherman",
            ["Miner"] = "CaveMiner",
        },
        jobValues = {},
    },
    customers = workspace["_game"].SpawnedCharacters,
    skills = {},
    items = replicatedStorage.Items,
    vehicleData = require(replicatedStorage.Modules.VehicleService.VehicleData),
    oldStaminaFunction = modules.staminaService.GetMaxStaminaValue
}
do
    for name, value in next, data.jobData.jobNames do
        data.jobData.jobValues[value] = name
    end
    for _, jobModule in next, clientScripts.JobHandler:GetChildren() do
        if jobModule:IsA("ModuleScript") then
            modules.jobs[jobModule.Name] = require(jobModule)
        end
    end
    for _, skill in next, clientStats.SkillData:GetChildren() do
        data.skills[skill.Name] = {
            name = skill.Name,
            level = skill.Value,
            progress = skill.Progress.Value
        }
        skill.Changed:Connect(function()
            data.skills[skill.Name].level = skill.Value
            data.skills[skill.Name].progress = skill.Progress.Value
        end)
        skill.Progress.Changed:Connect(function()
            data.skills[skill.Name].level = skill.Value
            data.skills[skill.Name].progress = skill.Progress.Value
        end)
    end
end

-- notification
local notification = {
    sideNotify = function(text)
        modules.sideNotify:CreateNotification("Bloxburger", 13681831497, text)
    end,
    messageNotify = function(text)
        modules.notification:MessageBox(text, "Bloxburger")
    end,
    alertNotify = function(text)
        modules.notification:AlertBox(text, "Bloxburger")
    end,
    scriptNotify = function(text)
        libraries.ui:Notify(text)
    end
}

-- configs
local host = "https://bloxburger.eu/api"
local featureConfig = {
    autoBuild = {
        saveTarget = localPlayer,
        loadId = nil,
        infoId = nil,
        startAfter = 0,
        webhookAutoBuild = false,
        saveDelay = false,
        maxMoneyForObject = 100000,
        useVehicles = true,
        useBlockbux = false,
        abortBuild = false,
        progressBar = nil,
        playerTargetTextbox = nil,
        useInventoryItems = true 
    },
    autoCook = {
        foodList = {},
        isCooking = false,
        storeInFridge = true,
        selectedFood = nil,
        cookAmount = 1,
        abortCooking = false
    },
    autoFarm = {
        selectedJob = nil,
        currentJob = nil,
        stopMethod = "Money",
        stopLevel = 9e9,
        stopMoney = 9e9,
        stopSeconds = 9e9,
        shouldStop = false,
        currentTick = nil,
        antiJobKick = false
    },
    autoMood = {
        toBoost = {},
        amountToBoost = 100,
        abortBoosting = false,
        isBoosting = false
    },
    autoSkills = {
        enabled = false,
        selectedSkill = nil,
        settings = {
            toCook = "Hot Dogs",
            toPlant = "Short Grass"
        },
        updateLabel = nil,
        enabledToggle = nil,
        plantList = {}
    },
    teleportation = {
        playerTarget = localPlayer,
        isTeleporting = false,
        clickTeleport = false,
        locations = {
            ["Pizza Planet"] = Vector3.new(1090.21826171875, 13.517683029174805, 250.5548858642578),
            ["Furniture Store"] = Vector3.new(1097.0374755859375, 13.517683029174805, 141.0622100830078),
            ["Night Club"] = Vector3.new(1082.0948486328125, 13.517683029174805, 30.16766357421875),
            ["City Hall"] = Vector3.new(992.8451538085938, 13.517683029174805, -226.8896942138672),
            ["Gym"] = Vector3.new(844.1101684570312, 13.517683029174805, -123.92965698242188),
            ["BFF Store"] = Vector3.new(839.2003173828125, 13.517683029174805, -4.984588623046875),
            ["Job Street"] = Vector3.new(885.9818725585938, 13.317681312561035, 207.40200805664062),
            ["River Side"] = Vector3.new(-101.85408020019531, 24.217683792114258, 323.4836730957031),
            ["Pizza Side"] = Vector3.new(1894.60009765625, 12.317683219909668, 325.9075622558594),
            ["Gas Station City"] = Vector3.new(1077.6693115234375, 13.517683029174805, 497.51776123046875),
            ["Gas Station Mountain"] = Vector3.new(1520.216796875, 89.91767883300781, -1280.045166015625),
            ["Park"] = Vector3.new(981.9990234375, 13.467683792114258, 1099.3074951171875),
            ["Mosk"] = Vector3.new(297.2958679199219, 101.41749572753906, 1219.9888916015625),
            ["Gliders"] = Vector3.new(401.7282409667969, 250.66799926757812, 736.2462158203125),
            ["Wood Street"] = Vector3.new(565.6150512695312, 13.168214797973633, 710.720458984375),
            ["Tenting Place"] = Vector3.new(-1040.8458251953125, 173.1077423095703, -957.4152221679688)
        }
    },
    vehicle = {
        modificationList = {
            ["Speed"] = {
                maxValue = 500,
                minValue = 5,
                currentValue = 5
            },
            ["Turning"] = {
                maxValue = 200,
                minValue = 1,
                currentValue = 10
            },
            ["Spring"] = {
                maxValue = 20,
                minValue = 0,
                currentValue = 0.1
            }
        },
        clonedModifications = nil,
        modificationEnabled = false
    },
    stats = {
        selectedPlayer = localPlayer,
        selectedSkill = nil
    },
    miscellaneous = {
        character = {
            age = "Adult",
            outfitTarget = localPlayer,
            outfitIndex = 1
        },
        noclip = false,
        environment = {
            time = 500,
            weather = "Clean",
            enabled = false,
            windSpeed = 1
        }
    },
    fun = {
        notification = {
            type = "Message",
            text = "This is a text."
        },
        payCheck = {
            amount = 100000
        }
    },
    neighborhood = {
        uploadToCloud = true
    }
}

-- detecting job changes
task.spawn(function()
    while task.wait() do
        local newJob = modules.jobManager.GetJob()
        if featureConfig.autoFarm.currentJob ~= newJob then
            featureConfig.autoFarm.currentJob = newJob
            notification.sideNotify("Your job has changed.\n" .. (newJob and ("Your job is now " .. data.jobData.jobValues[newJob] .. ".") or "You are now unemployed."))
        end
    end
end)

-- hooks
do
    local old old = hookmetamethod(game, "__namecall", function(self, ...)
        if getnamecallmethod() == "FireServer" and self == remotes["EndShift"] then
            if featureConfig.autoFarm.antiJobKick and not checkcaller() then
                return task.wait(9e9)
            end
        end

        return old(self, ...)
    end)
end

-- adding additional dicts in config
do
    -- food
    for foodName, data in next, data.foodList do
        if data.CookRecipe and not data.CanEat then
            table.insert(featureConfig.autoCook.foodList, foodName)
        end
    end

    -- plants
    for plantName, data in next, dataRequire(data.items.Garden) do
        if data.PlantData then
            table.insert(featureConfig.autoSkills.plantList, plantName)
        end
    end
end

-- functions
local functions functions = {
    stats = {
        getCurrentMoney = function()
            return clientStats.Money.Value
        end,
        getShiftInfo = function()
            local uiPath = mainUi.Bar.CharMenu.WorkFrame.WorkFrame

            return tonumber(string.gsub(uiPath.EarningsLabel.TextLabel.Text, " ", ""):match("(%d+)")), uiPath.TimeLabel.TextLabel.Text
        end,
        getJobProgress = function()
            local jobPath = clientStats.Job.Jobs[featureConfig.autoFarm.currentJob]
            local uiPath = mainUi.Bar.CharMenu.WorkFrame.WorkFrame.PromotionBar

            return jobPath.Value, jobPath.Progress.Value, tonumber(uiPath.Value.Text:match("/(%d+)"))
        end,
        getMood = function(moodType)
            return clientStats.MoodData[moodType].Value
        end
    },
    teleportation = {
        tween = function(position, finishTween)
            finishTween = finishTween or false
            local distanceToStop = (finishTween == false and 15) or (type(finishTween) == "number" and finishTween) or (finishTween == true and 1)
            local finishTween
            if distanceToStop == 1.5 then
                finishTween = true
            end

            local noclipConnection = runService.RenderStepped:Connect(noclip)
            controls:Disable()

            local vehicle = functions.utilities.getVehicle()
            local rootPart = vehicle and (vehicle:FindFirstChild("Body") or vehicle:WaitForChild("Body")) or humanoidRootPart
            local speed = 20

            local position = position - ((position - humanoidRootPart.Position).Unit * distanceToStop)
            local distance = (position - humanoidRootPart.Position).Magnitude

            local startInit = tick()
            local stopInit = distance / speed
            repeat
                rootPart.Velocity = (position - humanoidRootPart.Position).Unit * speed
        
                task.wait()
            until (tick() - startInit) >= stopInit
    
            rootPart.Velocity = Vector3.zero
            task.wait()
    
            if finishTween then
                humanoidRootPart.CFrame = CFrame.new(position)
            end
    
            noclipConnection:Disconnect()
            controls:Enable()
        end,
        pathfind = function(position, settings)
            local controls = require(localPlayer.PlayerScripts.PlayerModule):GetControls()
            controls:Disable()

            local path
            if type(settings) == "table" then
                path = pathfindingService:CreatePath(settings)
            else
                path = pathfindingService:CreatePath()
            end
            path:ComputeAsync(humanoidRootPart.Position, position)
            for _, waypoint in next, path:GetWaypoints() do
                humanoid:MoveTo(waypoint.Position)
                if waypoint.Action == Enum.PathWaypointAction.Jump then
                    humanoid.Jump = true
                end
                humanoid.MoveToFinished:Wait()
            end

            controls:Enable()
        end,
        jobTeleport = function(position, extra)
            if bloxburger.jobs.realisticMode then
                return functions.teleportation.pathfind(position, extra)
            elseif not bloxburger.jobs.realisticMode then
                return functions.teleportation.tween(position, extra)
            end
        end,
        underground = function(destination)
            local vehicle = functions.utilities.getVehicle()
            if not vehicle then
                return notification.sideNotify("Error, you need to be in a vehicle.")
            end
            if featureConfig.teleportation.isTeleporting then
                return notification.sideNotify("Error, you are already teleporting.\nPlease wait for the teleportation to complete")
            end
    
            featureConfig.teleportation.isTeleporting = true
    
            -- teleporting
            local vehicleSpeed = data.vehicleData[vehicle.Name:gsub("Vehicle_", "")].ForwardSpeed
            local body = vehicle.PrimaryPart or vehicle:WaitForChild("Body")
            body.CFrame = CFrame.new(body.Position.X, -50, body.Position.Z)
    
            local _target = destination
    
            local oldVelocity = body:FindFirstChild("BodyVelocity")
            oldVelocity.Parent = nil
    
            local velocity = Instance.new("BodyVelocity", body)
            velocity.P = 100
            velocity.MaxForce = Vector3.inf
            velocity.Velocity = Vector3.zero
    
            local target
            repeat
                target = typeof(_target) == "Vector3" and _target or _target.Position

                local calculated = (Vector3.new(target.X, -50, target.Z) - body.Position).Unit * vehicleSpeed
        
                velocity.Velocity = calculated
        
                task.wait()
            until (Vector3.new(target.X, -50, target.Z) - body.Position).Magnitude < 3.5
    
            velocity.Velocity = Vector3.zero
    
            body.CFrame = CFrame.new(target) * CFrame.new(0, 2.5, 0)
    
            velocity:Destroy()
            oldVelocity.Parent = body
            task.wait()
    
            featureConfig.teleportation.isTeleporting = false
        end
    },
    utilities = {
        cameraFunction = function(position, callback)
            local currentCamera = workspace.CurrentCamera
            currentCamera.CameraType = Enum.CameraType.Scriptable
            currentCamera.CFrame = CFrame.new(position)
            callback()
            currentCamera.CameraType = Enum.CameraType.Custom
        end,
        findOnPlot = function(item, plot)
            local plot = plot or functions.utilities.getCurrentPlot()
        
            local items = {}
            for _, descendant in next, plot.House:GetDescendants() do
                if descendant.Name:find(item) and descendant.ClassName:find("Part") and descendant.Parent.Parent.Name == "House" then
                    table.insert(items, descendant)
                end
            end
            table.sort(items, function(a, b)
                return localPlayer:DistanceFromCharacter(a.Position) < localPlayer:DistanceFromCharacter(b.Position)
            end)
            return items[1] or false
        end,
        randomPosition = function(position)
            return Vector3.new(math.random(1, 2) == 2 and (position.X + math.random(-1, 1)) or position.X, position.Y, math.random(1, 2) == 2 and (position.Z + math.random(-1, 1)) or position.Z)
        end,
        getTextboxName = function(player)
            if player.DisplayName == player.Name then
                return player.Name
            else
                return ("%s (%s)"):format(player.Name, player.DisplayName)
            end
        end,
        getCurrentPlot = function()
            return workspace.Plots[("Plot_%s"):format(localPlayer.Name)]
        end,
        attemptPayBills = function()
            local billAmount = modules.billService.GetBillAmount(localPlayer)
            if billAmount then
                if functions.stats.getCurrentMoney() < (1000 + billAmount) then
                    return false
                else
                    network:FireServer({
                        Type = "PayBills"
                    })
                    return true
                end
            end
            return true
        end,
        getVehicle = function()
            for _, model in next, character:GetChildren() do
                if model:IsA("Model") and model.Name:find("Vehicle_") then
                    return model
                end
            end
        end,
        getValueArrayFromInstance = function(instance)
            local array = {}
            for _, value in next, instance:GetChildren() do
                table.insert(array, value.Value)
            end
            return array
        end
    },
    automatic = {
        autoCook = function(foodName, status, dontStoreInFridgeOverwrite)
            -- replacing status if nil
            local status = status
            if not status then -- for features like auto mood
                status = {
                    index = 1,
                    max = 1,
                    label = {
                        Text = function() end
                    }
                }
            end

            status.label:Text(("Starting | (%s/%s)"):format(status.index, status.max))

            -- bill check
            if not functions.utilities.attemptPayBills() then
                return false, notification.sideNotify(("Pay your %s first."):format("Bills"))
            end
    
            -- variables    
            local oldCFrame = humanoidRootPart.CFrame
            local food = table.clone(data.foodList[foodName])
            local recipe = food.CookRecipe

            -- skill check
            local skillRequired = food.CookSkill or 0
            local currentSkill = clientStats.SkillData.Cooking.Value
            if currentSkill < skillRequired then
                return false, notification.sideNotify(("You don't have the required skill level to cook that.\n\nRequired: %s\nCurrent: %s"):format(skillRequired, currentSkill))
            end

            -- money check
            if functions.stats.getCurrentMoney() < food.CookPrice then
                return false, notification.sideNotify(("Not enough %s, missing $%s."):format("Money", food.CookPrice - functions.stats.getCurrentMoney()))
            end
    
            -- get fridge
            local fridge = functions.utilities.findOnPlot("Fridge")

            -- auto interact
            featureConfig.autoCook.isCooking = true

            -- get tools
            local finalRecipe = {}
            for _, ingredient in next, recipe do
                local function getTool(ingredient)
                    if type(ingredient) == "table" then
                        return getTool(ingredient[1])
                    end
                    
                    local method = modules.foodService.CookActions[ingredient]
                    local types = {}
                    if method.Types then
                        types = method.Types
                    elseif method.Type then
                        table.insert(types, method.Type)
                    end
                    
                    local type = types[1]

                    if type == "Counters" then
                        return functions.utilities.findOnPlot("Counter")
                    end
    
                    local ownedObjects = {}
                    local supportedObjects = {}

                    for object, data in next, data.appliances do
                        if data.Types and table.find(data.Types, type) then
                            table.insert(supportedObjects, object)
                        end
                    end

                    for _, object in next, functions.utilities.getCurrentPlot().House.Objects:GetChildren() do
                        if table.find(supportedObjects, object.Name) then
                            table.insert(ownedObjects, object)
                        end
                    end
                    for _, counter in next, functions.utilities.getCurrentPlot().House.Counters:GetChildren() do
                        if table.find(supportedObjects, counter.Name) then
                            table.insert(ownedObjects, counter)
                        end
                    end
                    
                    table.sort(ownedObjects, function(a, b)
                        return localPlayer:DistanceFromCharacter(a.Position) < localPlayer:DistanceFromCharacter(b.Position)
                    end)
    
                    local object = ownedObjects[1]

                    if object then
                        return object
                    end
                    return false, type
                end
    
                local tool, missing = getTool(ingredient)
                
                if not tool then
                    return false, notification.sideNotify(("Missing %s to cook: %s"):format(missing, ingredient))
                end
    
                table.insert(finalRecipe, tool)
            end
    
            -- get ingredient from fridge
            status.label:Text(("Getting ingredient | (%s/%s)"):format(status.index, status.max))
            functions.teleportation.tween(fridge.Position)
            do
                local interactionPath = 1
                while true do
                    network:FireServer({
                        Type = "Interact",
                        Target = fridge,
                        Path = tostring(interactionPath) 
                    })
    
                    task.wait()
    
                    network:FireServer({
                        Type = "TakeIngredient",
                        Name = foodName
                    })
    
                    interactionPath += 1
    
                    task.wait(0.15)
    
                    if modules.equipmentService:GetEquipped(localPlayer) or interactionPath == 5 then
                        break
                    end
                end
    
                if not modules.equipmentService:GetEquipped(localPlayer) then
                    return false, notification.sideNotify(("Failed getting ingredient: %s"):format(foodName))
                else
                    humanoid.Jump = true
                end
            end
    
            -- do step by step the recipe
            status.label:Text(("Cooking | (%s/%s)"):format(status.index, status.max))
            for _, tool in next, finalRecipe do
                functions.teleportation.tween(tool.Position)
    
                local interactionPath = 1
                
                while true do
                    network:FireServer({
                        Type = "Interact",
                        Target = tool,
                        Path = tostring(interactionPath)
                    })
    
                    interactionPath += 1
    
                    if not modules.equipmentService:GetEquipped(localPlayer) or interactionPath == 5 then
                        break
                    end
                    task.wait(0.1)
                end
    
                if modules.equipmentService:GetEquipped(localPlayer) then
                    return false, notification.sideNotify("There was an error cooking, please try again.")
                end
    
                repeat
                    task.wait()
                until modules.equipmentService:GetEquipped(localPlayer)

                task.wait(0.35)
            end
    
            -- waiting for food to hold
            repeat
                task.wait()
            until modules.equipmentService:GetEquipped(localPlayer) and modules.equipmentService:GetEquipped(localPlayer).Name == foodName
    
            -- store into fridge
            status.label:Text(("Storing food | (%s/%s)"):format(status.index, status.max))
            if featureConfig.autoCook.storeInFridge and not dontStoreInFridgeOverwrite then
                functions.teleportation.tween(fridge.Position)
    
                local interactionPath = 4
                while true do
                    network:FireServer({
                        Type = "Interact",
                        Target = fridge,
                        Path = tostring(interactionPath) 
                    })
    
                    interactionPath += 1
    
                    task.wait(0.15)
    
                    if not modules.equipmentService:GetEquipped(localPlayer) or interactionPath == 5 then
                        break
                    end
                end
    
                if not modules.equipmentService:GetEquipped(localPlayer) then
                    humanoid.Jump = true
                end
            end

            -- finishing    
            featureConfig.autoCook.isCooking = false

            return true
        end,
        boostMood = function(moodToBoost, status)
            -- pay bills
            if not functions.utilities.attemptPayBills() then
                return false, notification.sideNotify(("Pay your %s first."):format("Bills"))
            end
            
            -- variables
            local object

            if moodToBoost == "Fun" then
                -- get objects
                status.label:Text(("Fun: Getting Object (%s/%s)"):format(status.index, status.max))

                local supportedObjects = {}
                for object, data in next, dataRequire(data.items.Electronics) do
                    if data.Types then
                        if table.find(data.Types, "TV") then
                            table.insert(supportedObjects, {name = object, type = "TV"})
                        elseif table.find(data.Types, "Computer") then
                            table.insert(supportedObjects, {name = object, type = "Computer"})
                        end
                    end
                end

                local ownedObjects = {}
                for _, wall in next, functions.utilities.getCurrentPlot().House.Walls:GetChildren() do
                    if wall:FindFirstChild("ItemHolder") then
                        for _, item in next, wall.ItemHolder:GetChildren() do
                            for _, supportedObject in next, supportedObjects do
                                if supportedObject.name == item.Name then
                                    table.insert(ownedObjects, {item = item, type = supportedObject.type})
                                end
                            end
                        end
                    end
                end
                for _, counter in next, functions.utilities.getCurrentPlot().House.Counters:GetChildren() do
                    if counter:FindFirstChild("ItemHolder") then
                        for _, item in next, counter.ItemHolder:GetChildren() do
                            for _, supportedObject in next, supportedObjects do
                                if supportedObject.name == item.Name then
                                    table.insert(ownedObjects, {item = item, type = supportedObject.type})
                                end
                            end
                        end
                    end
                end
                for _, object in next, functions.utilities.getCurrentPlot().House.Objects:GetChildren() do
                    for _, supportedObject in next, supportedObjects do
                        if supportedObject.name == object.Name then
                            table.insert(ownedObjects, {item = object, type = supportedObject.type})
                        end
                    end
                    if object:FindFirstChild("ItemHolder") then
                        for _, item in next, object.ItemHolder:GetChildren() do
                            for _, supportedObject in next, supportedObjects do
                                if supportedObject.name == item.Name then
                                    table.insert(ownedObjects, {item = item, type = supportedObject.type})
                                end
                            end
                        end
                    end
                end

                table.sort(ownedObjects, function(a, b)
                    return localPlayer:DistanceFromCharacter(a.item.Position) < localPlayer:DistanceFromCharacter(b.item.Position)
                end)

                object = ownedObjects[1]

                if not object then
                    return false, notification.sideNotify("Error, no object to boost 'Fun' found.\nPlace a TV or a computer to make it work.")
                end

                -- going to object
                status.label:Text(("Fun: Going to %s (%s/%s)"):format(object.type, status.index, status.max))

                functions.teleportation.tween((object.item.CFrame * CFrame.new(0, 0, -2.5).Position), true)
                task.wait(0.15)
                
                -- interacting with object
                status.label:Text(("Fun (%s%%): Boosting Mood with %s (%s/%s)"):format(math.floor(functions.stats.getMood(moodToBoost)), object.type, status.index, status.max))

                if object.type == "TV" then
                    if not object.item.ObjectModel.Screen:FindFirstChildOfClass("SurfaceLight").Enabled then
                        network:FireServer({
                            Type = "Interact",
                            Target = object.item,
                            Path = "1"
                        })
                    end
                    task.wait(0.1)
                    network:FireServer({
                        Type = "Interact",
                        Target = object.item,
                        Path = "2"
                    })
                elseif object.type == "Computer" then
                    network:FireServer({
                        Type = "Interact",
                        Target = object.item,
                        Path = "1/1"
                    })
                end
            elseif moodToBoost == "Energy" then
                -- get objects
                status.label:Text(("Energy: Getting Object (%s/%s)"):format(status.index, status.max))

                local supportedObjects = {}
                for object, data in next, dataRequire(data.items.Beds) do
                    table.insert(supportedObjects, {name = object, type = "Sleep"})
                end

                local ownedObjects = {}
                for _, object in next, functions.utilities.getCurrentPlot().House.Objects:GetChildren() do
                    for _, supportedObject in next, supportedObjects do
                        if supportedObject.name == object.Name then
                            table.insert(ownedObjects, {item = object, type = supportedObject.type})
                        end
                    end
                    -- if object:FindFirstChild("ItemHolder") then
                    --     for _, item in next, object.ItemHolder:GetChildren() do
                    --         for _, supportedObject in next, supportedObjects do
                    --             if supportedObject.name == item.Name then
                    --                 table.insert(ownedObjects, {item = item, type = supportedObject.type})
                    --             end
                    --         end
                    --     end
                    -- end
                end

                table.sort(ownedObjects, function(a, b)
                    return localPlayer:DistanceFromCharacter(a.item.Position) < localPlayer:DistanceFromCharacter(b.item.Position)
                end)

                object = ownedObjects[1]

                if not object then
                    return false, notification.sideNotify("Error, no object to boost 'Energy' found.\nPlace a bed to make it work.")
                end

                -- going to object
                status.label:Text(("Energy: Going to %s (%s/%s)"):format(object.type, status.index, status.max))

                functions.teleportation.tween((object.item.CFrame.Position + Vector3.new(0, 2.5, 0)))
                task.wait(0.15)

                -- interacting with object
                status.label:Text(("Energy (%s%%): Boosting Mood with %s (%s/%s)"):format(math.floor(functions.stats.getMood(moodToBoost)), object.type, status.index, status.max))

                network:FireServer({
                    Type = "Interact",
                    Target = object.item,
                    Path = "1"
                })
            elseif moodToBoost == "Hunger" then
                -- get objects
                status.label:Text(("Hunger: Cooking Salad (%s/%s)"):format(status.index, status.max))

                -- cooking garden salad
                local result = functions.automatic.autoCook("Garden Salad", nil, true)
                if not result then
                    return false, "Auto cook failed."
                end
                local counter = functions.utilities.findOnPlot("Counter")

                object = {
                    item = nil,
                    type = "Eat"
                }

                -- going to object
                status.label:Text(("Hunger (%s%%): %sing Salad (%s/%s)"):format(math.floor(functions.stats.getMood(moodToBoost)), object.type, status.index, status.max))

                functions.teleportation.tween((counter.CFrame.Position + Vector3.new(0, 2.5, 0)), true)
                task.wait(0.1)
                network:FireServer({
                    Type = "Interact",
                    Path = "3",
                    Target = counter,
                    Pos = counter.Position + Vector3.new(0, 3.05, 0)
                })
                task.wait(0.05)
                counter:WaitForChild("ItemHolder")

                -- eat food
                local eatCount = 3
                while true do
                    if eatCount == 3 then
                        local chosenBowl
                        for _, bowl in next, counter.ItemHolder:GetChildren() do
                            if bowl.Name == "Garden Salad" then
                                local portions = 0
                                for _, portion in next, bowl.ObjectModel.Content:GetChildren() do
                                    if portion:IsA("Decal") and portion.Transparency == 0 then
                                        portions += 1
                                    end
                                end

                                if portions > 0 then
                                    chosenBowl = bowl
                                    break
                                end
                            end
                        end

                        repeat
                            network:FireServer({
                                Type = "Interact",
                                Path = "2",
                                Target = chosenBowl,
                            })
                            task.wait(0.1)
                        until modules.equipmentService:GetEquipped(localPlayer)
                        eatCount = 0
                        task.wait(0.1)
                    end

                    network:FireServer({
                        Type = "EatEquipped"
                    })

                    eatCount += 1

                    task.wait(1.5)
                    repeat
                        task.wait()
                    until not character:FindFirstChild("EatFoodWithFork_Items")

                    task.wait(0.25)

                    status.label:Text(("Hunger (%s%%): %sing Salad (%s/%s)"):format(math.floor(functions.stats.getMood(moodToBoost)), object.type, status.index, status.max))

                    if math.floor(functions.stats.getMood(moodToBoost)) >= featureConfig.autoMood.amountToBoost then
                        repeat
                            task.wait()
                            network:FireServer({
                                Type = "UnequipItem",
                                Item = modules.equipmentService:GetEquipped(localPlayer)
                            })
                        until not modules.equipmentService:GetEquipped(localPlayer)
                        break
                    end
                end
            elseif moodToBoost == "Hygiene" then
                -- get objects
                status.label:Text(("Hygiene: Getting Object (%s/%s)"):format(status.index, status.max))

                local supportedObjects = {}
                for object, data in next, dataRequire(data.items.Plumbing) do
                    if data.Types then
                        if table.find(data.Types, "Shower") then
                            table.insert(supportedObjects, {name = object, type = "Shower"})
                        elseif table.find(data.Types, "Bathtub") then
                            table.insert(supportedObjects, {name = object, type = "Bathtub"})
                        end
                    end
                end

                local ownedObjects = {}
                for _, object in next, functions.utilities.getCurrentPlot().House.Objects:GetChildren() do
                    for _, supportedObject in next, supportedObjects do
                        if supportedObject.name == object.Name then
                            table.insert(ownedObjects, {item = object, type = supportedObject.type})
                        end
                    end
                end
                for _, wall in next, functions.utilities.getCurrentPlot().House.Walls:GetChildren() do
                    if wall:FindFirstChild("ItemHolder") then
                        for _, item in next, wall.ItemHolder:GetChildren() do
                            for _, supportedObject in next, supportedObjects do
                                if supportedObject.name == item.Name then
                                    table.insert(ownedObjects, {item = item, type = supportedObject.type})
                                end
                            end
                        end
                    end
                end

                table.sort(ownedObjects, function(a, b)
                    return localPlayer:DistanceFromCharacter(a.item.Position) < localPlayer:DistanceFromCharacter(b.item.Position)
                end)

                object = ownedObjects[1]

                if not object then
                    return false, notification.sideNotify("Error, no object to boost 'Hygiene' found.\nPlace a bathtub or a shower to make it work.")
                end

                -- going to object
                status.label:Text(("Hygiene: Going to %s (%s/%s)"):format(object.type, status.index, status.max))

                functions.teleportation.tween((object.item.CFrame.Position + Vector3.new(0, 2.5, 0)))
                task.wait(0.15)

                -- interacting with object
                status.label:Text(("Hygiene (%s%%): Boosting Mood with %s (%s/%s)"):format(math.floor(functions.stats.getMood(moodToBoost)), object.type, status.index, status.max))

                network:FireServer({
                    Type = "Interact",
                    Target = object.item,
                    Path = "1"
                })
            end

            -- finishing
            if object.type ~= "Eat" then
                repeat
                    task.wait()
                    status.label:Text(("%s (%s%%): Boosting Mood with %s (%s/%s)"):format(moodToBoost, math.floor(functions.stats.getMood(moodToBoost)), object.type, status.index, status.max))
                until math.floor(functions.stats.getMood(moodToBoost)) >= featureConfig.autoMood.amountToBoost
            end

            if object.type == "TV" then
                status.label:Text(("%s: Finished, turning off %s (%s/%s)"):format(moodToBoost, object.type, status.index, status.max))
                network:FireServer({
                    Type = "Interact",
                    Target = object.item,
                    Path = "1"
                })
            elseif object.type == "Computer" or object.type == "Sleep" or object.type == "Bathtub" or object.type == "Shower" then
                network:FireServer({
                    Type = "Detach"
                })
            end

            return true
        end
    }
}

-- pathfinding modifiers
do
    local function addModifier(part, id)
        local oldModifier = part:FindFirstChildWhichIsA("PathfindingModifier")
        if oldModifier then
            oldModifier:Destroy()
        end

        local modifier = Instance.new("PathfindingModifier", part)
        modifier.PassThrough = false
        modifier.Label = id
        modifier.Name = "BloxburgerPathModifier" .. (additional or "")

        return modifier
    end

    for _, terrain in next, workspace.Environment["Terrain [LOCAL]"].TriangleTerrain:GetChildren() do
        addModifier(terrain, "IgnoreArea")
    end
    workspace.Environment["Terrain [LOCAL]"].TriangleTerrain.DescendantAdded:Connect(function(terrain)
        addModifier(terrain, "IgnoreArea")
    end)

    for _, plot in next, workspace.Plots:GetChildren() do
        local ground = plot:FindFirstChild("Ground")
        if ground then
            addModifier(ground, "Terrain")
        end
    end
    for _, road in next, workspace.Environment["Roads [LOCAL]"]:GetChildren() do
        if road.Name:find("Road") then
            for _, descendant in next, road:GetDescendants() do
                if descendant:IsA("BasePart") then
                    if descendant.Name:find("Road") then
                        addModifier(descendant, "Road")
                    elseif descendant.Name:find("Pavement") then
                        addModifier(descendant, "Pavement")
                    end
                end
            end
        end
    end
    for _, object in next, workspace.Environment.Locations.Pier:GetChildren() do
        if object.Name == "Park Bench" or object.Name == "Fence" then
            for _, descendant in next, object:GetDescendants() do
                addModifier(descendant, "IgnoreArea")
            end
        end
    end

    local ringPath = workspace.Environment.Locations.PizzaPlanet
    if ringPath:FindFirstChild("Ring") then
        addModifier(ringPath:FindFirstChild("Ring"), "PizzaRing")
    end
    ringPath.ChildAdded:Connect(function(child)
        if child.Name == "Ring" then
            addModifier(ringPath:FindFirstChild("Ring"), "PizzaRing")
        end
    end)
end

-- events
do
    -- player variables
    localPlayer.CharacterAdded:Connect(function(newCharacter)
        character = newCharacter
        humanoidRootPart = newCharacter:WaitForChild("HumanoidRootPart")
        humanoid = newCharacter:WaitForChild("Humanoid")
    end)

    -- auto cook
    clientScripts.HotbarUI.ChildAdded:Connect(function(child)
        if (child.Name == "Event" or child.ClassName:find("Event")) and featureConfig.autoCook.isCooking then
            task.wait()
            child:Fire(true)
        end
    end)

    -- time over write
    lighting.WindDirection:GetPropertyChangedSignal("Value"):Connect(function()
        if featureConfig.miscellaneous.environment.enabled then
            lighting.WindDirection.Value = Vector3.new(featureConfig.miscellaneous.environment.windSpeed, 0, featureConfig.miscellaneous.environment.windSpeed)
            lighting:FindFirstChild("TimeOfDay").Value = featureConfig.miscellaneous.environment.time
            lighting.Weather.Value = featureConfig.miscellaneous.environment.weather
        end
    end)

    -- ui toggle
    local function toggleUi(inputType)
        if inputType.UserInputType == Enum.UserInputType.Keyboard then
            if inputType.KeyCode == Enum.KeyCode.LeftAlt then
                libraries.ui:Toggle()
            end
        end
    end
    userInputService.InputBegan:Connect(toggleUi)
end

-- disable anti cheats
do
    require(clientScripts.JobHandler.PizzaPlanetDelivery).ShiftLoop = function()
        return task.wait(9e9)
    end
end
-----------------------

-- pages start here --

-----------------------

-- auto build
do
    -- elements
    ui.pages.autoBuild.sections = {}
    ui.pages.autoBuild.sections.save = ui.pages.autoBuild:Section("Save")
    ui.pages.autoBuild.sections.load = ui.pages.autoBuild:Section("Load")

    featureConfig.autoBuild.playerTargetTextbox = ui.pages.autoBuild.sections.save:Textbox("Target", "Player Name", function(t)
        local targetPlayer = libraries.utilities:GetPlayer(t)
        if targetPlayer then
            featureConfig.autoBuild.playerTargetTextbox:Selected(functions.utilities.getTextboxName(targetPlayer))
            featureConfig.autoBuild.saveTarget = targetPlayer
        else
            featureConfig.autoBuild.playerTargetTextbox:Selected(functions.utilities.getTextboxName(localPlayer))
            featureConfig.autoBuild.saveTarget = localPlayer
        end
    end)
    featureConfig.autoBuild.playerTargetTextbox:Selected(functions.utilities.getTextboxName(localPlayer))

    ui.pages.autoBuild.sections.save:Button("Save", function()
        -- get target's plot
        local targetPlot = workspace.Plots["Plot_" .. featureConfig.autoBuild.saveTarget.Name]
    
        -- save data
        local saveData = {
            Walls = {},
            Floors = {},
            Roofs = {},
            Fences = {},
            Counters = {},
            Objects = {},
            Basements = {},
            Pools = {},
            Paths = {},
            FrontObjects = {
                Mailbox = {
                    CFrame = nil,
                    Name = nil,
                    Color = nil
                },
                Trash = {
                    CFrame = nil,
                    Name = nil,
                    Color = nil
                },
                Position = nil
            },
            Information = {
                TotalCost = 0,
                TotalItems = 0,
                TotalBlockbux = 0,
                Gamepasses = {}
            }
        }
        local floorsSort = {
            id = 1,
            floors = {}
        }
    
        -- functions
        local encode = {
            position = function(position)
                return {position.X, position.Y, position.Z}
            end,
            cframe = function(cframe)
                return {cframe:components()}
            end
        }
        local decode = {
            cframe = function(cframe)
                return CFrame.new(unpack(cframe))
            end,
            position = function(position)
                return Vector3.new(unpack(position))
            end
        }
    
        local function findFloor(position)
            local raycastParams = RaycastParams.new()
            raycastParams.FilterType = Enum.RaycastFilterType.Whitelist
            raycastParams.FilterDescendantsInstances = {targetPlot}
            raycastParams.IgnoreWater = true
            local floorPart = workspace:Raycast(position, Vector3.new(0, -100, 0), raycastParams)
            local instance
            if floorPart then
                if floorPart.Instance then
                    instance = floorPart.Instance
                    if (instance.Parent ~= targetPlot.GroundParts) and (instance.Parent ~= targetPlot) then
                        if instance.Parent then
                            while instance.Parent.Parent ~= targetPlot.House do
                                instance = instance.Parent
                            end
                        else
                            return targetPlot.PrimaryPart
                        end
                    end
                else
                    return targetPlot.PrimaryPart
                end
            else
                return targetPlot.PrimaryPart
            end
            return instance
        end
        local function getFloorId(floor)
            local currentId = floorsSort.id
            floorsSort.id = floorsSort.id + 1
    
            table.insert(floorsSort.floors, {
                floor = floor,
                id = floorsSort.id
            })
            return currentId
        end
    
        local function savePosition(position)
            local position = modules.objectService:RoundToSaveResolution(CFrame.new(position)).Position
            return encode.position(targetPlot.Water.CFrame:PointToObjectSpace(position))
        end
        local function saveCFrame(cframe)
            local cframe = modules.objectService:RoundToSaveResolution(cframe)
            return encode.cframe(targetPlot.Water.CFrame:ToObjectSpace(cframe))
        end
        local function saveColor(object)
            local name = {}
            local number = modules.objectService:GetAppearanceData(object)
            for index, inner in next, number do
                if #inner == 0 then
                    name[index] = {}
                else
                    local insert = {}
                    insert[1] = BrickColor.new(tonumber(inner[1])).Name
                    if tonumber(inner[2]) == 0 then
                        insert[2] = 0
                    else
                        insert[2] = modules.materialData:GetMaterialFromID(tonumber(inner[2])).Name
                    end
                    name[index] = insert
                end
            end
            return name
        end
    
        local function canBeResized(itemName)
            return modules.resizeService.CanResize("", localPlayer, modules.itemService:GetItem(itemName))
        end
        local function getResizeData(item)
            local resizeData = item:GetAttribute("_resizeRootSize1")
            if not resizeData then
                return
            end
            return encode.position(resizeData)
        end
    
        local function roundVector3(vector3)
            local tempResult = {floorNumber(vector3.X, 1), floorNumber(vector3.Y, 1), floorNumber(vector3.Z, 1)}
            return tempResult
        end 
        local function updateCost(itemName)
            saveData.Information.TotalItems = saveData.Information.TotalItems + 1
    
            local item = modules.itemService:GetItem(itemName)
    
            if item then
                if item.Price and item.Price > 0 then
                    saveData.Information.TotalCost = saveData.Information.TotalCost + item.Price
                elseif item.BSPrice and item.BSPrice > 0 then
                    saveData.Information.TotalBlockbux = saveData.Information.TotalBlockbux + item.BSPrice
                end
            else
                saveData.Information.TotalCost = saveData.Information.TotalCost + modules.plotService:GetObjectValue(itemName)
            end
        end
    
        local function saveInnerObjects(holder, skipSideValue)
            if not holder:FindFirstChild("ItemHolder") or holder.ItemHolder:GetChildren() == 0 then
                return
            end
    
            local Objects = {}
            for _, object in pairs(holder.ItemHolder:GetChildren()) do
                if not object:IsA("BasePart") then
                    continue 
                end
                updateCost(object)
                
                local objectArray = {}
                local sideValue
                do
                    if object:FindFirstChild("SideValue") then
                        sideValue = object.SideValue.Value
                    else
                        sideValue = nil
                    end
                    if skipSideValue == true then
                        sideValue = nil
                    end
                end
    
                objectArray.Name = object.Name
                objectArray.CFrame = saveCFrame(object.CFrame)
                objectArray.Side = sideValue
                objectArray.Color = saveColor(object)
    
                do
                    if object:FindFirstChild("ObjectData") and object.ObjectData:FindFirstChild("Image") then
                        objectArray.Image = object.ObjectData:FindFirstChild("Image").Value
                    end
                end
                do
                    if canBeResized(object.Name) then
                        objectArray.ResizeData = getResizeData(object)
                    end
                end
    
                objectArray.Objects = saveInnerObjects(object, true)
    
                table.insert(Objects, objectArray)
            end
    
            return Objects
        end
    
        -- save objects
        do
            for _, wall in next, targetPlot.House.Walls:GetChildren() do
                if wall.Name == "Poles" then
                    continue
                end
                updateCost(wall)
        
                local insertValue = {}
        
                local wallTo, wallFrom = modules.wallService:GetWallEdges(wall)
        
                insertValue.Position = {
                    From = savePosition(wallFrom), 
                    To = savePosition(wallTo)
                }
    
                insertValue.Color = {
                    Right = saveColor(wall.RPart)[1],
                    Left = saveColor(wall.RPart)[2]
                }
    
                insertValue.Objects = saveInnerObjects(wall)
                
                table.insert(saveData.Walls, insertValue)
            end
            for _, floor in next, targetPlot.House.Floor:GetChildren() do
                updateCost(floor)
    
                local insertValue = {}
    
                insertValue.Id = getFloorId(floor)
                insertValue.Color = saveColor(floor)
                insertValue.Points = {}
                do
                    for _, point in next, floor.PointData:GetChildren() do
                        table.insert(insertValue.Points, savePosition(targetPlot.Ground.CFrame:PointToWorldSpace(point.Value) + Vector3.new(0, 0.05, 0)))
                    end
                end
                
                table.insert(saveData.Floors, insertValue)
            end
            for _, roof in next, targetPlot.House.Roof:GetChildren() do
                updateCost(roof)
    
                local inputValue = {}
                inputValue.Points = {}
                inputValue.Settings = {
                    Type = roof.Name,
                    IsPreview = true,
                }
                inputValue.Color = saveColor(roof)
    
                for _, point in next, roof.PointData:GetChildren() do
                    table.insert(inputValue.points, savePosition(targetPlot.Ground.CFrame:PointToWorldSpace(point.Value) + Vector3.new(0, 0.05, 0)))
                end
                for _, setting in next, roof.PropertyData:GetChildren() do
                    inputValue.Settings[roof.Name] = setting.Value
                end
    
                insertValue.Objects = saveInnerObjects(wall)
                
                table.insert(saveData.Roofs, insertValue)
            end
            for _, fence in next, targetPlot.House.Fences:GetChildren() do
                if fence.Name == "Poles" then
                    continue
                end
                updateCost(fence)
            
                local from, to = modules.fenceService:GetEdgePositions(fence)
    
                local inputValue = {}
                inputValue.From = savePosition(from)
                inputValue.To = savePosition(to)
                inputValue.Name = fence.Name
                inputValue.Color = saveColor(fence)
    
                inputValue.Objects = saveInnerObjects(fence)
    
                table.insert(saveData.Fences, inputValue)
            end
            for _, counter in next, targetPlot.House.Counters:GetChildren() do
                updateCost(counter)
                
                local inputValue = {}
                inputValue.Name = counter.Name
                inputValue.CFrame = saveCFrame(counter.CFrame) 
                inputValue.Color = saveColor(counter)
    
                do
                    local floorUsed = findFloor(counter.Position)
                    for _, array in next, floorsSort.floors do
                        if array.floor == floorUsed then
                            inputValue.Id = array.id
                            break
                        end
                    end
    
                    inputValue.Id = inputValue.Id or 0            
                end
    
                saveData.Objects = saveInnerObjects(counter)
                table.insert(saveData.Counters, inputValue)
            end
            for _, basement in next, targetPlot.House.Basements:GetChildren() do
                updateCost(basement)
                
                local basementData = {}
                basementDataName = basement.Name
                basementData.Center = saveCFrame(basement.PrimaryPart.CFrame)
                basementData.Size = {basement.PrimaryPart.Size.X, basement.PrimaryPart.Size.Z}
    
                table.insert(saveData.Basements, basementData)
            end
            for _, pool in next, targetPlot.House.Pools:GetChildren() do
                updateCost(pool)
                
                local poolData = {}
                poolData.Name = pool.Name
                poolData.Center = saveCFrame(pool.PrimaryPart.CFrame)
                poolData.Size = {pool.PrimaryPart.Size.X, pool.PrimaryPart.Size.Z}
                poolData.Color = saveColor(pool)
    
                saveData.Objects = saveInnerObjects(pool)
                table.insert(saveData.Pools, poolData)
            end
            for _, path in next, targetPlot.House.Paths:GetChildren() do
                if path.Name == "Poles" then
                    continue
                end
    
                updateCost(path)
                    
                local pathData = {}
                pathData.Name = path.Name
                pathData.Color = saveColor(path)
                pathData.To = savePosition(path.BPole.Value.Parent.Position)
                pathData.From = savePosition(path.FPole.Value.Parent.Position)
    
                pathData.Objects = saveInnerObjects(path)
                table.insert(saveData.Paths, object)
            end
            for _, object in next, targetPlot.House.Objects:GetChildren() do
                updateCost(object)
                
                local inputValue = {}
                inputValue["Name"] = object.Name
                inputValue["Color"] = saveColor(object)
                if object:GetAttribute("_transformStart") then
                    inputValue["CFrame"] = saveCFrame(CFrame.new(object:GetAttribute("_transformStart")))
                    inputValue["TransformData"] = saveCFrame(object.CFrame)
                else
                    inputValue["CFrame"] = saveCFrame(object.CFrame)
                end
    
                if object:FindFirstChild("ObjectData") and object.ObjectData:FindFirstChild("Image") then
                    inputValue["Image"] = object.ObjectData:FindFirstChild("Image").Value
                end
                do
                    local floorUsed = findFloor(object.Position)
                    for _, array in next, floorsSort.floors do
                        if array.floor == floorUsed then
                            inputValue.Id = array.id
                            break
                        end
                    end
    
                    inputValue.Id = inputValue.Id or 0            
                end
                do
                    if canBeResized(object.Name) then
                        inputValue.ResizeData = getResizeData(object)
                    end
                end
    
                inputValue.Objects = saveInnerObjects(object)
                table.insert(saveData.Objects, inputValue)
            end
        end
        -- save front objects
        do
            for _, item in next, targetPlot.House.FrontObjects.ItemHolder:GetChildren() do
                if item.Name:find("Mailbox") then
                    saveData.FrontObjects.Mailbox.Name = item.Name
                    saveData.FrontObjects.Mailbox.CFrame = saveCFrame(item.CFrame)
                    saveData.FrontObjects.Mailbox.Color = saveColor(item)
                else
                    saveData.FrontObjects.Trash.Name = item.Name
                    saveData.FrontObjects.Trash.CFrame = saveCFrame(item.CFrame)
                    saveData.FrontObjects.Trash.Color = saveColor(item)
                end
    
                updateCost(item)
            end
    
            local startFOPosition = targetPlot.Ground.CFrame * CFrame.Angles(0, math.rad(180), 0)
            local endPos = CFrame.new(targetPlot.House.FrontObjects.AttachPos.Position) * CFrame.Angles(0, math.rad(90), 0)
    
            saveData.FrontObjects.Position = endPos.Position.Z - startFOPosition.Position.Z
        end
    
        local deepsaveData = deepClone(saveData)
        do
            local function isPosition(tab)
                local count = 0
    
                if type(tab) ~= "table" or #tab < 3 then
                    return false
                end
    
                for _, number in next, tab do
                    if type(number) == "number" then
                        count = count + 1 
                    end
                end
    
                if count == 3 then
                    return decode.position(tab)
                elseif count > 3 then
                    return decode.cframe(tab)
                else
                    return false
                end
            end
            for _, value in next, deepsaveData do
                if not type(value) == "table" then
                    continue
                end
    
                local position = isPosition(value)
    
                if not position then
                    continue
                end
                if table.find(saveData.Information.Gamepasses, "Large Plot") and table.find(saveData.Information.Gamepasses, "Multiple Floors") then
                    break
                end
    
                if (position.X <= -80 or position.X >= 80 or position.Z >= 26) and not table.find(saveData.Information.Gamepasses, "Large Plot") then
                    table.insert(saveData.Information.Gamepasses, "Large Plot")
                end
                if position.Y >= 15.85 and not table.find(saveData.Information.Gamepasses, "Multiple Floors") then
                    table.insert(saveData.Information.Gamepasses, "Multiple Floors")
                end
            end
        end
    
        if #saveData.Basements > 0 then
            table.insert(saveData.Information.Gamepasses, "Basements")
        end
        for _, object in next, saveData.Objects do
            if object.ResizeData then
                table.insert(saveData.Information.Gamepasses, "Advanced Placement")
                break
            end
        end
    
        notification.sideNotify("Done check your output")
        print(jsonEncode(saveData, true))
    
        --do return end
    
        local buildRequestResponse = httpRequest(
            {
                Url = "https://bloxburger.eu/api/build-system/build.php",
                Method = "POST",
                Headers = {
                    ["Content-Type"] = "application/json"
                },
                Body = jsonEncode(saveData)
            }
        )
        if not buildRequestResponse.Success then
            GameNotify("There was an error saving the base, try again later.")
        end
    
        local response = jsonDecode(buildRequestResponse.Body)
    
        if response.status_code == 2 then
            notification.sideNotify(response.message.."\nId has been copied to your clipboard.")
            setclipboard(response.build_id)
        else
            notification.sideNotify("Unknown error has occurred: "..response.status_code .. "-" .. buildRequestResponse.StatusCode .. "\nScreenshot this message and dm it to " .. discordData.discord_username)
        end
    end)
    
    ui.pages.autoBuild.sections.load:Textbox("Build Id", "Build Id to Load", function(t)
        featureConfig.autoBuild.loadId = t
    end)
    ui.pages.autoBuild.sections.load:Button("Open House Browser", function()

    end)
    ui.pages.autoBuild.sections.load:Line()
    
    featureConfig.autoBuild.progressBar = ui.pages.autoBuild.sections.load:ReadOnly("Progress: Idling", {
        minValue = 1,
        maxValue = 1,
        currentValue = 1
    })
    ui.pages.autoBuild.sections.load:Button("Load", function()
        if not featureConfig.autoBuild.loadId then
            libraries.ui:Notify("Error loading. Id doesn't exist!")
            return false
        end
        if not clientStats.IsBuilding.Value then
            libraries.ui:Notify("Error loading. You need to be in build mode!")
            return false
        end
    
        local savedId = featureConfig.autoBuild.loadId
        local targetPlot = clientStats.IsBuilding.Value
    
        local isAdvanced = clientStats.Gamepasses["2237950"].Value
        local isTransform = clientStats.Gamepasses["109821762"].Value
    
        local startInit = tick()
    
        local loadData = nil
    
        -- load build
        do
            local buildRequestResponse = httpRequest(
                {
                    Url = "https://bloxburger.eu/build-system/build.php?build_id="..featureConfig.autoBuild.loadId,
                    Method = "GET",
                }
            )
            if not buildRequestResponse.Success then
                notification.sideNotify("There was an error loading the base, try again later.")
                return false
            end
    
            local response = jsonDecode(buildRequestResponse.Body)
    
            if response.status_code == 1 then
                loadData = jsonDecode(response.build_data)
            elseif response.status_code == 3 then
                notification.sideNotify(response.message)
                return false
            else
                notification.sideNotify("Unknown error has occurred: "..response.status_code .. "-" .. buildRequestResponse.StatusCode.."\nScreenshot this message and dm it to "..discordData.discord_username)
                return false
            end    
        end
    
        -- quick vars
        local doContinue = nil
    
        -- adding prompt
        local prompt
        local blur
        local toDisconnect = {}
        do
            blur = Instance.new("BlurEffect", lighting)
            blur.Size = 0
            blur.Enabled = true
        end
        do
            local AutoBuildPrompt = Instance.new("ScreenGui")
            local Frame = Instance.new("Frame")
            local Title = Instance.new("TextLabel")
            local MainFrame = Instance.new("Frame")
            local UIListLayout = Instance.new("UIListLayout")
            local TextLabel = Instance.new("TextLabel")
            local TotalItems = Instance.new("Frame")
            local TextLabel_2 = Instance.new("TextLabel")
            local Value = Instance.new("TextLabel")
            local TotalMoney = Instance.new("Frame")
            local TextLabel_3 = Instance.new("TextLabel")
            local Value_2 = Instance.new("TextLabel")
            local TotalBlockbux = Instance.new("Frame")
            local TextLabel_4 = Instance.new("TextLabel")
            local Value_3 = Instance.new("TextLabel")
            local TextLabel_5 = Instance.new("TextLabel")
            local UseBlockbux = Instance.new("Frame")
            local TextLabel_6 = Instance.new("TextLabel")
            local UICorner = Instance.new("UICorner")
            local Toggle = Instance.new("TextButton")
            local UICorner_2 = Instance.new("UICorner")
            local done = Instance.new("ImageLabel")
            local x = Instance.new("ImageLabel")
            local UICorner_3 = Instance.new("UICorner")
            local UseInventoryItems = Instance.new("Frame")
            local TextLabel_7 = Instance.new("TextLabel")
            local UICorner_4 = Instance.new("UICorner")
            local Toggle_2 = Instance.new("TextButton")
            local UICorner_5 = Instance.new("UICorner")
            local done_2 = Instance.new("ImageLabel")
            local x_2 = Instance.new("ImageLabel")
            local PlaceVehicles = Instance.new("Frame")
            local TextLabel_8 = Instance.new("TextLabel")
            local UICorner_6 = Instance.new("UICorner")
            local Toggle_3 = Instance.new("TextButton")
            local UICorner_7 = Instance.new("UICorner")
            local done_3 = Instance.new("ImageLabel")
            local x_3 = Instance.new("ImageLabel")
            local WebhookNotifier = Instance.new("Frame")
            local TextLabel_9 = Instance.new("TextLabel")
            local UICorner_8 = Instance.new("UICorner")
            local TextBox = Instance.new("TextBox")
            local UICorner_9 = Instance.new("UICorner")
            local UITextSizeConstraint = Instance.new("UITextSizeConstraint")
            local MaxMoney = Instance.new("Frame")
            local TextLabel_10 = Instance.new("TextLabel")
            local UICorner_10 = Instance.new("UICorner")
            local TextBox_2 = Instance.new("TextBox")
            local UICorner_11 = Instance.new("UICorner")
            local UITextSizeConstraint_2 = Instance.new("UITextSizeConstraint")
            local UICorner_12 = Instance.new("UICorner")
            local Cancel = Instance.new("TextButton")
            local UICorner_13 = Instance.new("UICorner")
            local Build = Instance.new("TextButton")
            local UICorner_14 = Instance.new("UICorner")
            local Shadow = Instance.new("ImageLabel")
        
            AutoBuildPrompt.Name = "AutoBuildPrompt"
            prompt = AutoBuildPrompt
            AutoBuildPrompt.Parent = coreGui
            AutoBuildPrompt.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
        
            Frame.Parent = AutoBuildPrompt
            Frame.BackgroundColor3 = Color3.fromRGB(22, 29, 33)
            Frame.Size = UDim2.new(0, 424, 0, 524)
            Frame.Position = UDim2.new(0.5 - (tonumber("0." .. tostring(Frame.Size.X.Offset)) / 4), 0, -2, 0)
        
            Title.Name = "Title"
            Title.Parent = Frame
            Title.BackgroundColor3 = Color3.fromRGB(248, 248, 248)
            Title.BackgroundTransparency = 1.000
            Title.Size = UDim2.new(0, 424, 0, 43)
            Title.Font = Enum.Font.GothamBold
            Title.Text = "Auto Build - Load"
            Title.TextColor3 = Color3.fromRGB(248, 248, 248)
            Title.TextSize = 16.000
        
            MainFrame.Name = "MainFrame"
            MainFrame.Parent = Frame
            MainFrame.BackgroundColor3 = Color3.fromRGB(19, 25, 29)
            MainFrame.BorderSizePixel = 0
            MainFrame.Position = UDim2.new(0.0256772302, 0, 0.100456648, 0)
            MainFrame.Size = UDim2.new(0, 403, 0, 405)
        
            UIListLayout.Parent = MainFrame
            UIListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
            UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
            UIListLayout.Padding = UDim.new(0, 1)
        
            TextLabel.Parent = MainFrame
            TextLabel.BackgroundColor3 = Color3.fromRGB(248, 248, 248)
            TextLabel.BackgroundTransparency = 1.000
            TextLabel.Position = UDim2.new(-0.0260545909, 0, 0, 0)
            TextLabel.Size = UDim2.new(0, 424, 0, 35)
            TextLabel.Font = Enum.Font.Gotham
            TextLabel.Text = "Information"
            TextLabel.TextColor3 = Color3.fromRGB(202, 203, 209)
            TextLabel.TextSize = 13.000
        
            TotalItems.Name = "TotalItems"
            TotalItems.Parent = MainFrame
            TotalItems.BackgroundColor3 = Color3.fromRGB(17, 17, 17)
            TotalItems.BackgroundTransparency = 1.000
            TotalItems.BorderSizePixel = 0
            TotalItems.Position = UDim2.new(0, 0, 0.0603448264, 0)
            TotalItems.Size = UDim2.new(0, 403, 0, 20)
        
            TextLabel_2.Parent = TotalItems
            TextLabel_2.BackgroundColor3 = Color3.fromRGB(248, 248, 248)
            TextLabel_2.BackgroundTransparency = 1.000
            TextLabel_2.Position = UDim2.new(0.0310173668, 0, 0, 0)
            TextLabel_2.Size = UDim2.new(0, 201, 0, 20)
            TextLabel_2.Font = Enum.Font.Gotham
            TextLabel_2.Text = "Total Items"
            TextLabel_2.TextColor3 = Color3.fromRGB(223, 223, 222)
            TextLabel_2.TextSize = 13.000
            TextLabel_2.TextXAlignment = Enum.TextXAlignment.Left
        
            Value.Name = "Value"
            Value.Parent = TotalItems
            Value.BackgroundColor3 = Color3.fromRGB(248, 248, 248)
            Value.BackgroundTransparency = 1.000
            Value.Position = UDim2.new(0.470223308, 0, 0, 0)
            Value.Size = UDim2.new(0, 201, 0, 20)
            Value.Font = Enum.Font.Gotham
            Value.Text = tostring(beautifyMoney(loadData.Information.TotalItems))
            Value.TextColor3 = Color3.fromRGB(202, 203, 209)
            Value.TextSize = 13.000
            Value.TextXAlignment = Enum.TextXAlignment.Right
        
            TotalMoney.Name = "TotalMoney"
            TotalMoney.Parent = MainFrame
            TotalMoney.BackgroundColor3 = Color3.fromRGB(17, 17, 17)
            TotalMoney.BackgroundTransparency = 1.000
            TotalMoney.BorderSizePixel = 0
            TotalMoney.Position = UDim2.new(0, 0, 0.0603448264, 0)
            TotalMoney.Size = UDim2.new(0, 403, 0, 20)
        
            TextLabel_3.Parent = TotalMoney
            TextLabel_3.BackgroundColor3 = Color3.fromRGB(248, 248, 248)
            TextLabel_3.BackgroundTransparency = 1.000
            TextLabel_3.Position = UDim2.new(0.0310173668, 0, 0, 0)
            TextLabel_3.Size = UDim2.new(0, 201, 0, 20)
            TextLabel_3.Font = Enum.Font.Gotham
            TextLabel_3.Text = "Total Money"
            TextLabel_3.TextColor3 = Color3.fromRGB(223, 223, 222)
            TextLabel_3.TextSize = 13.000
            TextLabel_3.TextXAlignment = Enum.TextXAlignment.Left
        
            Value_2.Name = "Value"
            Value_2.Parent = TotalMoney
            Value_2.BackgroundColor3 = Color3.fromRGB(248, 248, 248)
            Value_2.BackgroundTransparency = 1.000
            Value_2.Position = UDim2.new(0.470223308, 0, 0, 0)
            Value_2.Size = UDim2.new(0, 201, 0, 20)
            Value_2.Font = Enum.Font.Gotham
            Value_2.Text = "$" .. tostring(beautifyMoney(loadData.Information.TotalCost))
            Value_2.TextColor3 = Color3.fromRGB(202, 203, 209)
            Value_2.TextSize = 13.000
            Value_2.TextXAlignment = Enum.TextXAlignment.Right
        
            TotalBlockbux.Name = "TotalBlockbux"
            TotalBlockbux.Parent = MainFrame
            TotalBlockbux.BackgroundColor3 = Color3.fromRGB(17, 17, 17)
            TotalBlockbux.BackgroundTransparency = 1.000
            TotalBlockbux.BorderSizePixel = 0
            TotalBlockbux.Position = UDim2.new(0, 0, 0.0603448264, 0)
            TotalBlockbux.Size = UDim2.new(0, 403, 0, 20)
        
            TextLabel_4.Parent = TotalBlockbux
            TextLabel_4.BackgroundColor3 = Color3.fromRGB(248, 248, 248)
            TextLabel_4.BackgroundTransparency = 1.000
            TextLabel_4.Position = UDim2.new(0.0310173668, 0, 0, 0)
            TextLabel_4.Size = UDim2.new(0, 201, 0, 20)
            TextLabel_4.Font = Enum.Font.Gotham
            TextLabel_4.Text = "Total Blockbux"
            TextLabel_4.TextColor3 = Color3.fromRGB(223, 223, 222)
            TextLabel_4.TextSize = 13.000
            TextLabel_4.TextXAlignment = Enum.TextXAlignment.Left
        
            Value_3.Name = "Value"
            Value_3.Parent = TotalBlockbux
            Value_3.BackgroundColor3 = Color3.fromRGB(248, 248, 248)
            Value_3.BackgroundTransparency = 1.000
            Value_3.Position = UDim2.new(0.470223308, 0, 0, 0)
            Value_3.Size = UDim2.new(0, 201, 0, 20)
            Value_3.Font = Enum.Font.Gotham
            Value_3.Text = "B$" .. tostring(beautifyMoney(loadData.Information.TotalBlockbux))
            Value_3.TextColor3 = Color3.fromRGB(202, 203, 209)
            Value_3.TextSize = 13.000
            Value_3.TextXAlignment = Enum.TextXAlignment.Right
        
            TextLabel_5.Parent = MainFrame
            TextLabel_5.BackgroundColor3 = Color3.fromRGB(248, 248, 248)
            TextLabel_5.BackgroundTransparency = 1.000
            TextLabel_5.Position = UDim2.new(-0.0260545909, 0, 0, 0)
            TextLabel_5.Size = UDim2.new(0, 424, 0, 35)
            TextLabel_5.Font = Enum.Font.Gotham
            TextLabel_5.Text = "Settings"
            TextLabel_5.TextColor3 = Color3.fromRGB(202, 203, 209)
            TextLabel_5.TextSize = 13.000
        
            UseBlockbux.Name = "UseBlockbux"
            UseBlockbux.Parent = MainFrame
            UseBlockbux.BackgroundColor3 = Color3.fromRGB(22, 29, 33)
            UseBlockbux.BorderSizePixel = 0
            UseBlockbux.Position = UDim2.new(0, 0, 0.280172408, 0)
            UseBlockbux.Size = UDim2.new(0, 390, 0, 38)
        
            TextLabel_6.Parent = UseBlockbux
            TextLabel_6.BackgroundColor3 = Color3.fromRGB(248, 248, 248)
            TextLabel_6.BackgroundTransparency = 1.000
            TextLabel_6.Position = UDim2.new(0.0310173705, 0, 0, 0)
            TextLabel_6.Size = UDim2.new(0, 201, 0, 38)
            TextLabel_6.Font = Enum.Font.Gotham
            TextLabel_6.Text = "Use Blockbux"
            TextLabel_6.TextColor3 = Color3.fromRGB(223, 223, 222)
            TextLabel_6.TextSize = 13.000
            TextLabel_6.TextXAlignment = Enum.TextXAlignment.Left
        
            UICorner.CornerRadius = UDim.new(0, 3)
            UICorner.Parent = UseBlockbux
        
            Toggle.Name = "Toggle"
            Toggle.Parent = UseBlockbux
            Toggle.BackgroundColor3 = Color3.fromRGB(202, 203, 209)
            Toggle.Position = UDim2.new(0.912999988, 0, 0.210999995, 0)
            Toggle.Size = UDim2.new(0, 22, 0, 22)
            Toggle.AutoButtonColor = false
            Toggle.Font = Enum.Font.SourceSans
            Toggle.Text = ""
            Toggle.TextColor3 = Color3.fromRGB(0, 0, 0)
            Toggle.TextSize = 14.000
        
            UICorner_2.CornerRadius = UDim.new(0, 3)
            UICorner_2.Parent = Toggle
        
            done.Name = "done"
            done.Parent = Toggle
            done.BackgroundTransparency = 1.000
            done.Size = UDim2.new(0, 22, 0, 22)
            done.ZIndex = 2
            done.Image = "rbxassetid://3926305904"
            done.ImageRectOffset = Vector2.new(644, 204)
            done.ImageRectSize = Vector2.new(36, 36)
            done.ImageTransparency = 1.000
        
            x.Name = "x"
            x.Parent = Toggle
            x.BackgroundTransparency = 1.000
            x.LayoutOrder = 3
            x.Size = UDim2.new(0, 22, 0, 22)
            x.ZIndex = 2
            x.Image = "rbxassetid://3926305904"
            x.ImageRectOffset = Vector2.new(924, 724)
            x.ImageRectSize = Vector2.new(36, 36)
    
            local useBlockbuxToggle = false
            Toggle.MouseButton1Click:Connect(function()
                if not useBlockbuxToggle then
                    tweenObject(Toggle.done, 0.2, {
                        ImageTransparency = 0
                    })
                    tweenObject(Toggle.x, 0.2, {
                        ImageTransparency = 1
                    })
                    useBlockbuxToggle = true
                    featureConfig.autoBuild.useBlockbux = true
                elseif useBlockbuxToggle then
                    tweenObject(Toggle.done, 0.2, {
                        ImageTransparency = 1
                    })
                    tweenObject(Toggle.x, 0.2, {
                        ImageTransparency = 0
                    })
                    useBlockbuxToggle = false
                    featureConfig.autoBuild.useBlockbux = false
                end
            end)
            table.insert(toDisconnect, runService.RenderStepped:Connect(function()
                tweenObject(Toggle, 0.1, {
                    BackgroundColor3 = useBlockbuxToggle and libraries.ui:GetTheme() or Color3.fromRGB(202, 203, 209)
                })
            end))
        
            UICorner_3.Parent = MainFrame
        
            UseInventoryItems.Name = "UseInventoryItems"
            UseInventoryItems.Parent = MainFrame
            UseInventoryItems.BackgroundColor3 = Color3.fromRGB(22, 29, 33)
            UseInventoryItems.BorderSizePixel = 0
            UseInventoryItems.Position = UDim2.new(0, 0, 0.280172408, 0)
            UseInventoryItems.Size = UDim2.new(0, 390, 0, 38)
        
            TextLabel_7.Parent = UseInventoryItems
            TextLabel_7.BackgroundColor3 = Color3.fromRGB(248, 248, 248)
            TextLabel_7.BackgroundTransparency = 1.000
            TextLabel_7.Position = UDim2.new(0.0310173705, 0, 0, 0)
            TextLabel_7.Size = UDim2.new(0, 201, 0, 38)
            TextLabel_7.Font = Enum.Font.Gotham
            TextLabel_7.Text = "Use Inventory Items"
            TextLabel_7.TextColor3 = Color3.fromRGB(223, 223, 222)
            TextLabel_7.TextSize = 13.000
            TextLabel_7.TextXAlignment = Enum.TextXAlignment.Left
        
            UICorner_4.CornerRadius = UDim.new(0, 3)
            UICorner_4.Parent = UseInventoryItems
        
            Toggle_2.Name = "Toggle"
            Toggle_2.Parent = UseInventoryItems
            Toggle_2.BackgroundColor3 = Color3.fromRGB(202, 203, 209)
            Toggle_2.Position = UDim2.new(0.912999988, 0, 0.210999995, 0)
            Toggle_2.Size = UDim2.new(0, 22, 0, 22)
            Toggle_2.AutoButtonColor = false
            Toggle_2.Font = Enum.Font.SourceSans
            Toggle_2.Text = ""
            Toggle_2.TextColor3 = Color3.fromRGB(0, 0, 0)
            Toggle_2.TextSize = 14.000
        
            UICorner_5.CornerRadius = UDim.new(0, 3)
            UICorner_5.Parent = Toggle_2
        
            done_2.Name = "done"
            done_2.Parent = Toggle_2
            done_2.BackgroundTransparency = 1.000
            done_2.Size = UDim2.new(0, 22, 0, 22)
            done_2.ZIndex = 2
            done_2.Image = "rbxassetid://3926305904"
            done_2.ImageRectOffset = Vector2.new(644, 204)
            done_2.ImageRectSize = Vector2.new(36, 36)
            done_2.ImageTransparency = 1.000
        
            x_2.Name = "x"
            x_2.Parent = Toggle_2
            x_2.BackgroundTransparency = 1.000
            x_2.LayoutOrder = 3
            x_2.Size = UDim2.new(0, 22, 0, 22)
            x_2.ZIndex = 2
            x_2.Image = "rbxassetid://3926305904"
            x_2.ImageRectOffset = Vector2.new(924, 724)
            x_2.ImageRectSize = Vector2.new(36, 36)
    
            local useInventoryToggle = false
            Toggle_2.MouseButton1Click:Connect(function()
                if not useInventoryToggle then
                    tweenObject(Toggle_2.done, 0.2, {
                        ImageTransparency = 0
                    })
                    tweenObject(Toggle_2.x, 0.2, {
                        ImageTransparency = 1
                    })
                    useInventoryToggle = true
                    featureConfig.autoBuild.useInventoryItems = true
                elseif useInventoryToggle then
                    tweenObject(Toggle_2.done, 0.2, {
                        ImageTransparency = 1
                    })
                    tweenObject(Toggle_2.x, 0.2, {
                        ImageTransparency = 0
                    })
                    useInventoryToggle = false
                    featureConfig.autoBuild.useInventoryItems = false
                end
            end)
            table.insert(toDisconnect, runService.RenderStepped:Connect(function()
                tweenObject(Toggle_2, 0.1, {
                    BackgroundColor3 = useInventoryToggle and libraries.ui:GetTheme() or Color3.fromRGB(202, 203, 209)
                })
            end))
        
            PlaceVehicles.Name = "PlaceVehicles"
            PlaceVehicles.Parent = MainFrame
            PlaceVehicles.BackgroundColor3 = Color3.fromRGB(22, 29, 33)
            PlaceVehicles.BorderSizePixel = 0
            PlaceVehicles.Position = UDim2.new(0, 0, 0.280172408, 0)
            PlaceVehicles.Size = UDim2.new(0, 390, 0, 38)
        
            TextLabel_8.Parent = PlaceVehicles
            TextLabel_8.BackgroundColor3 = Color3.fromRGB(248, 248, 248)
            TextLabel_8.BackgroundTransparency = 1.000
            TextLabel_8.Position = UDim2.new(0.0310173705, 0, 0, 0)
            TextLabel_8.Size = UDim2.new(0, 201, 0, 38)
            TextLabel_8.Font = Enum.Font.Gotham
            TextLabel_8.Text = "Place Vehicles"
            TextLabel_8.TextColor3 = Color3.fromRGB(223, 223, 222)
            TextLabel_8.TextSize = 13.000
            TextLabel_8.TextXAlignment = Enum.TextXAlignment.Left
        
            UICorner_6.CornerRadius = UDim.new(0, 3)
            UICorner_6.Parent = PlaceVehicles
        
            Toggle_3.Name = "Toggle"
            Toggle_3.Parent = PlaceVehicles
            Toggle_3.BackgroundColor3 = Color3.fromRGB(202, 203, 209)
            Toggle_3.Position = UDim2.new(0.912999988, 0, 0.210999995, 0)
            Toggle_3.Size = UDim2.new(0, 22, 0, 22)
            Toggle_3.AutoButtonColor = false
            Toggle_3.Font = Enum.Font.SourceSans
            Toggle_3.Text = ""
            Toggle_3.TextColor3 = Color3.fromRGB(0, 0, 0)
            Toggle_3.TextSize = 14.000
        
            UICorner_7.CornerRadius = UDim.new(0, 3)
            UICorner_7.Parent = Toggle_3
        
            done_3.Name = "done"
            done_3.Parent = Toggle_3
            done_3.BackgroundTransparency = 1.000
            done_3.Size = UDim2.new(0, 22, 0, 22)
            done_3.ZIndex = 2
            done_3.Image = "rbxassetid://3926305904"
            done_3.ImageRectOffset = Vector2.new(644, 204)
            done_3.ImageRectSize = Vector2.new(36, 36)
            done_3.ImageTransparency = 1.000
        
            x_3.Name = "x"
            x_3.Parent = Toggle_3
            x_3.BackgroundTransparency = 1.000
            x_3.LayoutOrder = 3
            x_3.Size = UDim2.new(0, 22, 0, 22)
            x_3.ZIndex = 2
            x_3.Image = "rbxassetid://3926305904"
            x_3.ImageRectOffset = Vector2.new(924, 724)
            x_3.ImageRectSize = Vector2.new(36, 36)
    
            local useVehicles = false
            Toggle_3.MouseButton1Click:Connect(function()
                if not useVehicles then
                    tweenObject(Toggle_3.done, 0.2, {
                        ImageTransparency = 0
                    })
                    tweenObject(Toggle_3.x, 0.2, {
                        ImageTransparency = 1
                    })
                    useVehicles = true
                    featureConfig.autoBuild.useVehicles = true
                elseif useVehicles then
                    tweenObject(Toggle_3.done, 0.2, {
                        ImageTransparency = 1
                    })
                    tweenObject(Toggle_3.x, 0.2, {
                        ImageTransparency = 0
                    })
                    useVehicles = false
                    featureConfig.autoBuild.useVehicles = false
                end
            end)
            table.insert(toDisconnect, runService.RenderStepped:Connect(function()
                tweenObject(Toggle_3, 0.1, {
                    BackgroundColor3 = useVehicles and libraries.ui:GetTheme() or Color3.fromRGB(202, 203, 209)
                })
            end))
        
            WebhookNotifier.Name = "WebhookNotifier"
            WebhookNotifier.Parent = MainFrame
            WebhookNotifier.BackgroundColor3 = Color3.fromRGB(22, 29, 33)
            WebhookNotifier.BorderSizePixel = 0
            WebhookNotifier.Position = UDim2.new(0.0161290318, 0, 0.730603456, 0)
            WebhookNotifier.Size = UDim2.new(0, 390, 0, 40)
        
            TextLabel_9.Parent = WebhookNotifier
            TextLabel_9.BackgroundColor3 = Color3.fromRGB(248, 248, 248)
            TextLabel_9.BackgroundTransparency = 1.000
            TextLabel_9.Position = UDim2.new(0.031017283, 0, 0.0204544067, 0)
            TextLabel_9.Size = UDim2.new(0, 170, 0, 38)
            TextLabel_9.Font = Enum.Font.Gotham
            TextLabel_9.Text = "Webhook Notifier"
            TextLabel_9.TextColor3 = Color3.fromRGB(223, 223, 222)
            TextLabel_9.TextSize = 13.000
            TextLabel_9.TextXAlignment = Enum.TextXAlignment.Left
        
            UICorner_8.CornerRadius = UDim.new(0, 3)
            UICorner_8.Parent = WebhookNotifier
        
            TextBox.Parent = WebhookNotifier
            TextBox.BackgroundColor3 = Color3.fromRGB(20, 26, 30)
            TextBox.Position = UDim2.new(0.456410259, 0, 0.100000001, 0)
            TextBox.Size = UDim2.new(0, 200, 0, 30)
            TextBox.Font = Enum.Font.Gotham
            TextBox.PlaceholderText = "Webhook Url"
            TextBox.Text = ""
            TextBox.TextColor3 = Color3.fromRGB(200, 200, 200)
            TextBox.TextScaled = true
            TextBox.TextSize = 14.000
            TextBox.TextWrapped = true
            TextBox.FocusLost:Connect(function()
                print(TextBox.Text, "")
                featureConfig.autoBuild.webhookAutoBuild = TextBox.Text
            end)
        
            UICorner_9.CornerRadius = UDim.new(0, 4)
            UICorner_9.Parent = TextBox
        
            UITextSizeConstraint.Parent = TextBox
            UITextSizeConstraint.MaxTextSize = 14
            UITextSizeConstraint.MinTextSize = 10
        
            MaxMoney.Name = "MaxMoney"
            MaxMoney.Parent = MainFrame
            MaxMoney.BackgroundColor3 = Color3.fromRGB(22, 29, 33)
            MaxMoney.BorderSizePixel = 0
            MaxMoney.Position = UDim2.new(0.0161290318, 0, 0.730603456, 0)
            MaxMoney.Size = UDim2.new(0, 390, 0, 40)
        
            TextLabel_10.Parent = MaxMoney
            TextLabel_10.BackgroundColor3 = Color3.fromRGB(248, 248, 248)
            TextLabel_10.BackgroundTransparency = 1.000
            TextLabel_10.Position = UDim2.new(0.031017283, 0, 0.0204544067, 0)
            TextLabel_10.Size = UDim2.new(0, 163, 0, 38)
            TextLabel_10.Font = Enum.Font.Gotham
            TextLabel_10.Text = "Max. Money Per Object"
            TextLabel_10.TextColor3 = Color3.fromRGB(223, 223, 222)
            TextLabel_10.TextSize = 13.000
            TextLabel_10.TextXAlignment = Enum.TextXAlignment.Left
        
            UICorner_10.CornerRadius = UDim.new(0, 3)
            UICorner_10.Parent = MaxMoney
        
            TextBox_2.Parent = MaxMoney
            TextBox_2.BackgroundColor3 = Color3.fromRGB(20, 26, 30)
            TextBox_2.Position = UDim2.new(0.532340646, 0, 0.100000001, 0)
            TextBox_2.Size = UDim2.new(0, 170, 0, 30)
            TextBox_2.Font = Enum.Font.Gotham
            TextBox_2.PlaceholderText = "Max Money"
            TextBox_2.Text = "100,000"
            TextBox_2.TextColor3 = Color3.fromRGB(200, 200, 200)
            TextBox_2.TextScaled = true
            TextBox_2.TextSize = 14.000
            TextBox_2.TextWrapped = true
            TextBox_2.FocusLost:Connect(function()
                if not tonumber(TextBox_2.Text) then
                    TextBox_2.Text = ("$" .. tostring(featureConfig.autoBuild.maxMoneyForObject))
                    return false
                end
                featureConfig.autoBuild.maxMoneyForObject = tonumber(TextBox_2.Text)
                task.wait()
                TextBox_2.Text = ("$" .. tostring(TextBox_2.Text))
            end)
            TextBox_2.Text = ("$" .. tostring(featureConfig.autoBuild.maxMoneyForObject))
        
            UICorner_11.CornerRadius = UDim.new(0, 4)
            UICorner_11.Parent = TextBox_2
        
            UITextSizeConstraint_2.Parent = TextBox_2
            UITextSizeConstraint_2.MaxTextSize = 14
            UITextSizeConstraint_2.MinTextSize = 10
        
            UICorner_12.Parent = Frame
        
            Cancel.Name = "Cancel"
            Cancel.Parent = Frame
            Cancel.BackgroundColor3 = Color3.fromRGB(19, 25, 29)
            Cancel.Position = UDim2.new(0.054245282, 0, 0.902671754, 0)
            Cancel.Size = UDim2.new(0, 170, 0, 42)
            Cancel.AutoButtonColor = false
            Cancel.Font = Enum.Font.GothamBold
            Cancel.Text = "Cancel"
            Cancel.TextColor3 = Color3.fromRGB(255, 255, 255)
            Cancel.TextSize = 14.000
            Cancel.TextStrokeColor3 = Color3.fromRGB(66, 66, 66)
            Cancel.TextStrokeTransparency = 0.000
    
            local STROKE = Instance.new("UIStroke", Cancel)
            STROKE.Color = Color3.fromRGB(54, 54, 54)
            STROKE.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
            STROKE.Thickness = 1
            STROKE.LineJoinMode = Enum.LineJoinMode.Round
            STROKE.Name = "stroke"
        
            UICorner_13.CornerRadius = UDim.new(0, 5)
            UICorner_13.Parent = Cancel
        
            Build.Name = "Build"
            Build.Parent = Frame
            Build.BackgroundColor3 = Color3.fromRGB(19, 25, 29)
            Build.Position = UDim2.new(0.530660391, 0, 0.902671754, 0)
            Build.Size = UDim2.new(0, 170, 0, 42)
            Build.AutoButtonColor = false
            Build.Font = Enum.Font.GothamBold
            Build.Text = "Build"
            Build.TextColor3 = Color3.fromRGB(255, 255, 255)
            Build.TextSize = 14.000
            Build.TextStrokeColor3 = Color3.fromRGB(66, 66, 66)
            Build.TextStrokeTransparency = 0.000
    
            local STROKE = Instance.new("UIStroke", Build)
            STROKE.Color = Color3.fromRGB(54, 54, 54)
            STROKE.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
            STROKE.Thickness = 1
            STROKE.LineJoinMode = Enum.LineJoinMode.Round
            STROKE.Name = "stroke"
        
            UICorner_14.CornerRadius = UDim.new(0, 5)
            UICorner_14.Parent = Build
        
            Shadow.Name = "Shadow"
            Shadow.Parent = Frame
            Shadow.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
            Shadow.BackgroundTransparency = 1.000
            Shadow.Position = UDim2.new(-0.113974452, 0, 0.153876722, 0)
            Shadow.Size = UDim2.new(0, 520, 0, 517)
            Shadow.ZIndex = 0
            Shadow.Image = "rbxassetid://12825872869"
            Shadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
        end
        do
            tweenObject(blur, 1.5, {
                Size = 30
            })
            tweenObject(prompt.Frame, 1, {
                Position = UDim2.new(0.5 - (tonumber("0." .. tostring(prompt.Frame.Size.X.Offset)) / 4), 0, 0.25, 0)
            })
    
            prompt.Frame.Cancel.MouseEnter:Connect(function()
                tweenObject(prompt.Frame.Cancel.stroke, 0.1, {
                    Color = Color3.fromRGB(0, 111, 167)
                })
                tweenObject(prompt.Frame.Cancel, 0.1, {
                    TextSize = 10
                })
            end)
            prompt.Frame.Cancel.MouseLeave:Connect(function()
                tweenObject(prompt.Frame.Cancel.stroke, 0.1, {
                    Color = Color3.fromRGB(54, 54, 54)
                })
                tweenObject(prompt.Frame.Cancel, 0.1, {
                    TextSize = 14
                })
            end)
            prompt.Frame.Build.MouseEnter:Connect(function()
                tweenObject(prompt.Frame.Build.stroke, 0.1, {
                    Color = Color3.fromRGB(0, 111, 167)
                })
                tweenObject(prompt.Frame.Build, 0.1, {
                    TextSize = 10
                })
            end)
            prompt.Frame.Build.MouseLeave:Connect(function()
                tweenObject(prompt.Frame.Build.stroke, 0.1, {
                    Color = Color3.fromRGB(54, 54, 54)
                })
                tweenObject(prompt.Frame.Build, 0.1, {
                    TextSize = 14
                })
            end)
    
            prompt.Frame.Cancel.MouseButton1Click:Connect(function()
                tweenObject(prompt.Frame, 1, {
                    Position = UDim2.new(0.5 - (tonumber("0." .. tostring(prompt.Frame.Size.X.Offset)) / 4), 0, 2, 0)
                })
                tweenObject(blur, 1.5, {
                    Size = 0
                })
                task.wait(2)
    
                prompt:Destroy()
            end)
            prompt.Frame.Build.MouseButton1Click:Connect(function()
                tweenObject(prompt.Frame, 1, {
                    Position = UDim2.new(0.5 - (tonumber("0." .. tostring(prompt.Frame.Size.X.Offset)) / 4), 0, 2, 0)
                })
                tweenObject(blur, 1.5, {
                    Size = 0
                })
                task.wait(2)
    
                prompt:Destroy()
            end)
    
            prompt.Frame.Cancel.MouseButton1Click:Connect(function()
                doContinue = false
            end)
            prompt.Frame.Build.MouseButton1Click:Connect(function()
                doContinue = true
            end)
        end
    
        repeat
            task.wait()
        until doContinue ~= nil
        for _, connection in next, toDisconnect do
            connection:Disconnect()
        end
        if doContinue == false then
            return
        end
    
        -- setting build status
        local buildIndex = 0
        local function updateStatus(text)
            text = "Placing " .. text
            buildIndex = buildIndex + 1
    
            task.spawn(function()
                featureConfig.autoBuild.progressBar:Update({
                    minValue = 1,
                    maxValue = loadData.Information.TotalItems,
                    currentValue = buildIndex
                }, text)
            end)
        end
        
        -- configs
        local floors = {}
    
        -- saving structure data
        local toDo = {}
    
        local decode = {
            cframe = function(cframe)
                return CFrame.new(unpack(cframe))
            end,
            position = function(position)
                return Vector3.new(unpack(position))
            end
        }
        local function loadPosition(position)
            return targetPlot.Water.CFrame:PointToWorldSpace(
                decode.position(position)
            )
        end
        local function loadCFrame(cframe)
            return targetPlot.Water.CFrame:ToWorldSpace(
                decode.cframe(cframe)
            )
        end
        local function loadColor(origin)
            local objects = {}
            if not pcall(function()
                    for i = 1, 4 do
                        if origin[i] and (#origin[i] ~= 0) then
                            objects[i] = {}
                            if origin[i][1] ~= 0 then
                                objects[i][1] = BrickColor.new(origin[i][1]).Number
                            else
                                objects[i][1] = 0
                            end
                            if origin[i][2] ~= 0 then
                                if modules.materialData.Materials[tostring(origin[i][2])] then
                                    objects[i][2] = modules.materialData.Materials[tostring(origin[i][2])].ID
                                else
                                    objects[i][2] = 0
                                end
                            else
                                objects[i][2] = 0
                            end
                        else
                            objects[i] = {}
                        end
                    end
                end)
            then
                return
            else
                return objects
            end
        end
        local function loadRotation(cframe)
            local lookVector = cframe.lookVector
            local rotation = - math.atan2(lookVector.Z, lookVector.X) - math.pi * 0.5
            return rotation < 0 and 2 * math.pi + rotation or rotation
        end
    
        local function isAbleToPlace(itemName)
            local items = getupvalue(modules.itemService.GetItem, 1)._itemCache
    
            if items[itemName] and items[itemName].Seasonal and #items[itemName].Seasonal > 0 then
                print(("Aborted %s, because of season item"):format(itemName))
                return false
            end
    
            local item = modules.itemService:GetItem(itemName)
    
            if item and (item.Price or item.BSPrice) then
                if item.Hidden then
                    print(("Aborted %s, because of hidden"):format(itemName))
                    return false
                end
                if item.BSPrice then
                    if not featureConfig.autoBuild.useBlockbux then
                        print(("Aborted %s, because of blockbux"):format(itemName))
                        return false
                    end
                end
                if item.Price >= featureConfig.autoBuild.maxMoneyForObject then
                    print(("Aborted %s, because of max money for object"):format(itemName))
                    return false
                end
                for _, v in pairs(data.items.Food:GetChildren()) do
                    if v.Name == itemName then
                        print(("Aborted %s, because of food is not placeable"):format(itemName))
                        return false
                    end
                end
                for _, v in pairs(data.items.Vehicles:GetChildren()) do
                    if v.Name == itemName and not featureConfig.autoBuild.useVehicles == true then
                        print(("Aborted %s, because of vehicle"):format(itemName))
                        return false
                    end
                end
                for _, v in pairs(data.items.Structural:GetChildren()) do
                    if itemName == v.Name then
                        print(("Aborted %s, because of blacklisted"):format(itemName))
                        return false
                    end
                end
                if modules.itemService.CallItemMethod("", "IsLocked", item, localPlayer) then
                    print(("Aborted %s, because of skill level"):format(ItitemNameemName))
                    return false
                end
                if modules.itemService.CallItemMethod("", "IsSeasonal", item, localPlayer) then
                    print(("Aborted %s, because of season item"):format(itemName))
                    return false
                end      
                return true
            end
            return false
        end
    
        local function registerFloor(floor, id)
            table.insert(floors, {
                floor = floor,
                id = id
            })
        end
        local function getFloorFromId(id)
            if id == 0 then
                return targetPlot.PrimaryPart
            end
            for _, value in next, floors do
                if value.id == id then
                    return value.floor
                end
            end
            return targetPlot.PrimaryPart
        end
    
        local makeStructureCount = nil
        local function makeStructure(data, except, init)
            except = except or false
            init = init or false
            if type(init) == "number" and not makeStructureCount then
                makeStructureCount = init
            end
    
            local dataType = data.Type
            local isPlacing = dataType:find("Place") and dataType:gsub("Place", "")
            if dataType:find("Resize") or dataType:find("Color") then
                isPlacing = false
            end
            local finishRepeating = false
            local connection
    
            if isPlacing then
                local pathToStructures = nil
                if dataType == "PlaceObject" and except == "Fence" then
                    pathToStructures = targetPlot.House:FindFirstChild("Fence" .. "s") or targetPlot.House:FindFirstChild("Fence")
                elseif dataType == "PlaceObject" and except == "Counter" then
                    pathToStructures = targetPlot.House:FindFirstChild("Counter" .. "s") or targetPlot.House:FindFirstChild("Counter")
                else
                    pathToStructures = targetPlot.House:FindFirstChild(isPlacing .. "s") or targetPlot.House:FindFirstChild(isPlacing)
                end
    
                connection = pathToStructures.ChildAdded:Connect(function(part)
                    finishRepeating = part
                end)
                task.spawn(function()
                    pathToStructures.ChildAdded:Wait()
                    if not finishRepeating then
                        repeat task.wait() until finishRepeating
                    end
                end)
            else
                finishRepeating = true
            end
    
            local result, cost = network:InvokeServer(data)
    
            if result or cost then
                if isPlacing then
                    repeat task.wait() until finishRepeating
                end
                makeStructureCount = nil
                return (type(finishRepeating) ~= "boolean" and finishRepeating or result), cost
            elseif not result and type(init) == "number" and ((init - makeStructureCount) > 5) then
                if connection then
                    connection:Disconnect()
                end
                makeStructureCount = nil
                return false, 0
            end
    
            task.wait(0.15)
    
            if connection then
                connection:Disconnect()
            end
            return makeStructure(data, except, tick())
        end
        local function makeInnerStructure(data, holder, init)
            local dataType = data.Type
    
            init = init or false
            if type(init) == "number" and not makeStructureCount then
                makeStructureCount = init
            end
    
            local finishRepeating = false
            
            local connection = holder.DescendantAdded:Connect(function(part)
                if part.Name == data.Name then
                    finishRepeating = part
                end
            end)
            task.spawn(function()
                holder.DescendantAdded:Wait()
                repeat task.wait() until finishRepeating
                connection:Disconnect()
            end)
    
            local result, cost = network:InvokeServer(data)
    
            if result or cost then
                repeat task.wait() until finishRepeating
                makeStructureCount = nil
                return finishRepeating or result
            elseif not result and type(init) == "number" and ((init - makeStructureCount) > 5) then
                makeStructureCount = nil
                connection:Disconnect()
                return false, 0
            end
    
            task.wait(0.15)
    
            connection:Disconnect()
            return makeInnerStructure(data, holder, tick())
        end
        local function modifyStructure(data)
            if data.Type:find("Color") and data.Data and data.Data[1] and #data.Data[1] == 0 then
                return
            end
            table.insert(toDo, data)
        end
        local function placeInnerStructures(mainStructure, mainPart)
            if mainStructure.Objects then
                for _, object in next, mainStructure.Objects do
                    updateStatus("Inner Object")
    
                    if replicatedStorage.Modules["_Objects"].FenceService:FindFirstChild(object.Name) then continue end -- fix
                    if not isAbleToPlace(object.Name) then
                        continue
                    end
    
                    local side = nil
                    if object.Side == 1 then
                        side = true
                    elseif object.Side == -1 then
                        side = false
                    end
                    object.Color = loadColor(object.Color)
    
                    local part, cost = makeInnerStructure({
                        Type = "PlaceObject",
                        Name = object.Name,
                        Side = side,
                        TargetModel = mainPart,
                        Pos = loadCFrame(object.CFrame).Position,
                        Rot = loadRotation(loadCFrame(object.CFrame)) 
                    }, mainPart)
                    if not part then
                        continue
                    end
    
                    if object.ResizeData then
                        modifyStructure({
                            Type = "ResizeObject",
                            Object = part,
                            Data = {DecodeV(object.ResizeData)}
                        })
                    end
                    
                    modifyStructure({
                        Type = "ColorObject",
                        Object = part,
                        UseMaterials = true,
                        Data = loadColor(object.Color)
                    })
    
                    placeInnerStructures(object, part)
                end
            end
        end
    
        -- place front objects
        if loadData.FrontObjects then
            do
                local trash, trashCost
                local mailbox, mailboxCost
        
                updateStatus("Placing Mailbox")
                repeat
                    if targetPlot.House.FrontObjects.ItemHolder:FindFirstChild(loadData.FrontObjects.Trash.Name) then
                        trash, trashCost = true, true
                        continue
                    end
        
                    trash, trashCost = network:InvokeServer({
                        Type = "PlaceObject",
                        Name = loadData.FrontObjects.Trash.Name,
                        TargetModel = targetPlot.House.FrontObjects,
                        Pos = loadCFrame(loadData.FrontObjects.Trash.CFrame).Position,
                        Rot = loadRotation(loadCFrame(loadData.FrontObjects.Trash.CFrame)) 
                    })
                    task.wait(0.15)
                until trash and trashCost
        
                updateStatus("Placing Trash")
                repeat
                    if targetPlot.House.FrontObjects.ItemHolder:FindFirstChild(loadData.FrontObjects.Mailbox.Name) then
                        mailbox, mailboxCost = true, true
                        continue
                    end
        
                    mailbox, mailboxCost = network:InvokeServer({
                        Type = "PlaceObject",
                        Name = loadData.FrontObjects.Mailbox.Name,
                        TargetModel = targetPlot.House.FrontObjects,
                        Pos = loadCFrame(loadData.FrontObjects.Mailbox.CFrame).Position,
                        Rot = loadRotation(loadCFrame(loadData.FrontObjects.Mailbox.CFrame)) 
                    })
                    task.wait(0.15)
                until mailbox and mailboxCost
        
                repeat
                    task.wait()
                until targetPlot.House.FrontObjects.ItemHolder:FindFirstChild(loadData.FrontObjects.Mailbox.Name) and targetPlot.House.FrontObjects.ItemHolder:FindFirstChild(loadData.FrontObjects.Trash.Name)
        
                for _, item in next, targetPlot.House.FrontObjects.ItemHolder:GetChildren() do
                    if item.Name == loadData.FrontObjects.Mailbox.Name then
                        modifyStructure({
                            Type = "ColorObject",
                            Object = item,
                            UseMaterials = true,
                            Data = loadColor(loadData.FrontObjects.Mailbox.Color)
                        })
                    elseif item.Name == loadData.FrontObjects.Trash.Name then
                        modifyStructure({
                            Type = "ColorObject",
                            Object = item,
                            UseMaterials = true,
                            Data = loadColor(loadData.FrontObjects.Trash.Color)
                        })
                    end
                end
        
                network:InvokeServer({
                    Type = "MoveFrontObjects",
                    Pos = loadData.FrontObjects.Position
                })
            end
        end
    
        -- place parts
        do
            for _, wall in next, loadData.Walls do
                updateStatus("Wall")
    
                local part, cost = makeStructure({
                    Type = "PlaceWall",
                    To = loadPosition(wall.Position.To),
                    From = loadPosition(wall.Position.From)
                })
                if not part then
                    continue
                end
                
                modifyStructure({
                    Type = "ColorObject",
                    Object = part,
                    UseMaterials = true,
                    Data = loadColor({wall.Color.Right}),
                    Side = "R"
                })
                modifyStructure({
                    Type = "ColorObject",
                    Object = part,
                    UseMaterials = true,
                    Data = loadColor({wall.Color.Left}),
                    Side = "L"
                })
    
                placeInnerStructures(wall, part)
            end
            for _, floor in next, loadData.Floors do
                updateStatus("Floor")
    
                for index, point in next, floor.Points do
                    floor.Points[index] = loadPosition(point)
                end
    
                local part, cost = makeStructure({
                    Type = "PlaceFloor",
                    Points = floor.Points
                })
                if not part then
                    continue
                end
                
                modifyStructure({
                    Type = "ColorObject",
                    Object = part,
                    UseMaterials = true,
                    Data = loadColor(floor.Color)
                })
    
                registerFloor(part, floor.Id)
            end
            for _, roof in next, loadData.Roofs do
                updateStatus("Roof")
    
                for index, point in next, roof.Points do
                    roof.Points[index] = loadPosition(point)
                end
    
                local part, cost = makeStructure({
                    Type = "PlaceRoof",
                    Points = roof.Points,
                    Settings = roof.Settings
                })
                if not part then
                    continue
                end
                
                modifyStructure({
                    Type = "ColorObject",
                    Object = part,
                    UseMaterials = true,
                    Data = loadColor(roof.Color)
                })
    
                placeInnerStructures(roof, part)
            end
            for _, basement in next, loadData.Basements do
                updateStatus("Basement")
    
                local originalCFrame = {targetPlot.Ground.CFrame:ToObjectSpace(loadCFrame(basement.Center)):components()}
                originalCFrame[2] = 0.0000001
                local endPosition = CFrame.new(unpack(originalCFrame))
    
                local part, cost = makeStructure({
                    Type = "PlaceBasement",
                    Center = endPosition,
                    Size = Vector2.new(unpack(basement.Size))
                })
                --if not part then
                    -- continue no need
                --end
            end
            for _, pool in next, loadData.Pools do
                updateStatus("Pool")
    
                local originalTable = {targetPlot.Ground.CFrame:ToObjectSpace(loadCFrame(pool.Center)):components()}
                originalTable[2] = 0.0000001
                local endPosition = CFrame.new(unpack(originalTable))
    
                local part, cost = makeStructure({
                    Type = "PlacePool",
                    ItemType = pool.Name,
                    Center = endPosition,
                    Size = Vector2.new(unpack(pool.Size))
                })
                if not part then
                    continue
                end
                
                modifyStructure({
                    Type = "ColorObject",
                    Object = part,
                    UseMaterials = true,
                    Data = loadColor(pool.Color)
                })
    
                placeInnerStructures(pool, part)
            end
            for _, fence in next, loadData.Fences do
                updateStatus("Fence")
    
                local part, cost = makeStructure({
                    Type = "PlaceObject",
                    Name = fence.Name,
                    StartPos = loadPosition(fence.From),
                    Pos = loadPosition(fence.To)
                }, "Fence")
                if not part then
                    continue
                end
                
                modifyStructure({
                    Type = "ColorObject",
                    Object = part,
                    UseMaterials = true,
                    Data = loadColor(fence.Color)
                })
    
                placeInnerStructures(fence, part)
            end
            for _, path in next, loadData.Paths do
                updateStatus("Path")
    
                local part, cost = makeStructure({
                    Type = "PlacePath",
                    To = loadPosition(path.To),
                    From = loadPosition(path.From)
                })
                if not part then
                    continue
                end
                
                modifyStructure({
                    Type = "ColorObject",
                    Object = part,
                    UseMaterials = true,
                    Data = loadColor(path.Color)
                })
    
                placeInnerStructures(path, part)
            end
            for _, counter in next, loadData.Counters do
                updateStatus("Counter")
    
                local part, cost = makeStructure({
                    Type = "PlaceObject",
                    Rot = loadRotation(loadCFrame(counter.CFrame)),
                    Pos = loadCFrame(counter.CFrame).Position,
                    Name = counter.Name,
                    TargetModel = getFloorFromId(counter.Id)
                }, "Counter")
                if not part then
                    continue
                end
                
                modifyStructure({
                    Type = "ColorObject",
                    Object = part,
                    UseMaterials = true,
                    Data = loadColor(counter.Color)
                })
    
                placeInnerStructures(counter, part)
            end
            for _, object in next, loadData.Objects do
                updateStatus("Object")
    
                if not isAbleToPlace(object.Name) then
                    continue
                end
    
                local part, cost = makeStructure({
                    Type = "PlaceObject",
                    Rot = loadRotation(loadCFrame(object.CFrame)),
                    Pos = loadCFrame(object.CFrame).Position,
                    Name = object.Name,
                    TargetModel = getFloorFromId(object.Id)
                })
                if not part then
                    continue
                end
                
                modifyStructure({
                    Type = "ColorObject",
                    Object = part,
                    UseMaterials = true,
                    Data = loadColor(object.Color)
                })
                if object.TransformData then
                    local offset = decode.cframe(object.TransformData) - Vector3.new(0, 3.75, 0)
                    print(offset)
                    local start = tick()
                    local result
                    repeat
                        result = network:InvokeServer({
                            Type = "TransformObject",
                            Offset = offset,
                            Object = part
                        })
                        task.wait(0.1)
                    until result or (tick() - start) > 3
                end
                if object.ResizeData then
                    modifyStructure({
                        Type = "ResizeObject",
                        Object = part,
                        Data = {decode.position(object.ResizeData)}
                    })
                end
    
                placeInnerStructures(object, part)
            end
        end
    
        for _, taskData in next, toDo do
            task.spawn(function()
                featureConfig.autoBuild.progressBar:Update(1, #toDo, _, (taskData.Type:find("Resize") and "Resizing Parts") or (taskData.Type:find("Color") and "Coloring Parts") or "Transforming Parts")
            end)
    
            makeStructure(taskData)
        end
    
        notification.sideNotify("Auto Build\n\nSuccessfully built the house.\nTook " .. tostring(floorNumber(tick() - startInit, 1)) .. " seconds for " .. tostring(loadData.Information.TotalItems) .. " Parts.")
        task.spawn(function()
            if featureConfig.autoBuild.webhookAutoBuild then
                httpRequest({
                    Url = featureConfig.autoBuild.webhookAutoBuild,
                    Method = "POST",
                    Headers = {
                        ["Content-Type"] = "application/json"
                    },
                    Body = jsonEncode(
                        {
                            embeds = {
                                {
                                    title = "**Bloxburger** - Done Building",
                                    description = ("Successfully built the house-id ``%s`` for the user %s."):format(savedId, localPlayer.Name .. " (" .. tostring(localPlayer.UserId) .. ")"),
                                    color = tonumber(("0x%s"):format("008cff")),
                                }
                            } 
                        }
                    )
                })
            end
        end)
    
        task.spawn(function()
            featureConfig.autoBuild.progressBar:Update(1, 1, 1, "Progress: Idling")
        end)
    end)
    ui.pages.autoBuild.sections.load:Button("Bulldoze Current Plot", function()
        network:FireServer({
            Type = "BulldozePlot",
            Exclude = {},
        })
        local Guis = localPlayer.PlayerGui
        local FirstStep = Guis:WaitForChild("_MessageBox")
        for _, v in pairs(FirstStep.MessageBox.ButtonFrame:GetChildren()) do
            if v:IsA("ImageButton") and (v.TextLabel.Text == "Yes" or v.TextLabel.Text == "Ja" or v.TextLabel.Text == "Si") then
                for d, k in pairs(getconnections(v.Activated)) do k:Fire() end
            end
        end
        local SecondStep = Guis:WaitForChild("_InputBox").InputBox
        SecondStep.ContentBox.Text = localPlayer.Name
        for d, k in pairs(getconnections(SecondStep.Ok.Activated)) do k:Fire() end
    end)
    ui.pages.autoBuild.sections.load:Line()
    ui.pages.autoBuild.sections.load:Button("Show Hologram", function()   
        local targetPlot = clientStats.IsBuilding.Value
        if not targetPlot then
            notification.sideNotify("Error loading. You need to be in build mode.")
            return
        end
    
        local faceTypes = {"Top", "Bottom", "Left", "Right", "Front", "Back"}
        local settings = {
            WallTransparency = 0.45,
            RoofTransparency = 0,
            FloorTransparency = 0,
            PoolTransparency = 0.1,
            PathTransparency = 0,
            ObjectTransparency = 0,
            BasementTransparency = 0.1,
        }
    
        modules.wallService.QueueClientWallUpdate = function() end
    
        local decode = {
            cframe = function(cframe)
                return CFrame.new(unpack(cframe))
            end,
            position = function(position)
                return Vector3.new(unpack(position))
            end
        }
    
        local function loadPosition(position)
            return targetPlot.Water.CFrame:PointToWorldSpace(
                decode.position(position)
            )
        end
        local function loadCFrame(cframe)
            return targetPlot.Water.CFrame:ToWorldSpace(
                decode.cframe(cframe)
            )
        end
        local function loadColor(origin)
            local objects = {}
            if not pcall(function()
                    for i = 1, 4 do
                        if origin[i] and (#origin[i] ~= 0) then
                            objects[i] = {}
                            if origin[i][1] ~= 0 then
                                objects[i][1] = BrickColor.new(origin[i][1]).Number
                            else
                                objects[i][1] = 0
                            end
                            if origin[i][2] ~= 0 then
                                if modules.materialData.Materials[tostring(origin[i][2])] then
                                    objects[i][2] = modules.materialData.Materials[tostring(origin[i][2])].ID
                                else
                                    objects[i][2] = 0
                                end
                            else
                                objects[i][2] = 0
                            end
                        else
                            objects[i] = {}
                        end
                    end
                end)
            then
                return
            else
                return objects
            end
        end
        local function loadRotation(cframe)
            local lookVector = cframe.lookVector
            local rotation = -math.atan2(lookVector.Z, lookVector.X) - math.pi * 0.5
            return rotation < 0 and 2 * math.pi + rotation or rotation
        end
    
        local allItems = modules.fenceService.Items
        local toVanish = {}
        local loadData = nil
    
        -- get id
        do
            local buildRequestResponse = httpRequest(
                {
                    Url = "https://bloxburger.eu/build-system/build.php?build_id="..featureConfig.autoBuild.loadId:gsub(".txt", ""),
                    Method = "GET",
                }
            )
            if not buildRequestResponse.Success then
                notification.sideNotify("There was an error fetching the base, try again later.\nDo NOT report this message.")
                return
            end
            buildRequestResponse = jsonDecode(buildRequestResponse.Body)
        
            if buildRequestResponse.status_code == 1 then
                loadData = jsonDecode(buildRequestResponse.build_data)
            elseif buildRequestResponse.status_code == 3 then
                notification.sideNotify(buildRequestResponse.message)
                return
            else
                notification.sideNotify("API Error:\nReport this to Hold: " .. tostring(buildRequestResponse.status_code))
                return
            end
        end
    
        local previewFolder = Instance.new("Folder", nil)
        previewFolder.Name = "Bloxburger_Preview"
    
        local function newGhost(properties)
            local clone = Instance.new("Part", previewFolder)
    
            clone.Anchored = true
            clone.CanCollide = false
            clone.Transparency = 0
            clone.Material = Enum.Material.Plastic
    
            for property, value in next, properties do 
                clone[property] = value
            end
    
            return clone
        end
        local function colorPart(partToColor, colorTable)
            xpcall(function()
                local blacklistedItems = {"Beam", "ParticleEmitter"}
    
                if partToColor:IsA("Decal") then
                    partToColor.Color3 = BrickColor.new(colorTable[1]).Color
                    return
                elseif partToColor.ClassName:find("Light") or partToColor.ClassName:find("Fire") then
                    partToColor.Color = BrickColor.new(colorTable[1]).Color
                    return
                elseif partToColor.ClassName:find("RodConstraint") then
                    partToColor.Color = BrickColor.new(colorTable[1])
                    return
                elseif table.find(blacklistedItems, partToColor.ClassName) then
                    return
                end
    
                if colorTable[1] then
                    partToColor.BrickColor = BrickColor.new(colorTable[1])
                end
        
                xpcall(function()
                    partToColor.Material = Enum.Material[ colorTable[2] ]
                end, function()
                    if colorTable and colorTable[2] and not tonumber(colorTable[2]) and type(colorTable[2]) ~= "number" then
                        for _, face in next, faceTypes do
                            local tempTexture = Instance.new("Texture", partToColor)
    
                            tempTexture.Face = Enum.NormalId[face]
                            tempTexture.Texture = replicatedStorage.Modules._Data.MaterialData.Textures:FindFirstChild(colorTable[2]:gsub("*", "")).Texture
                            tempTexture.StudsPerTileU = replicatedStorage.Modules._Data.MaterialData.Textures:FindFirstChild(colorTable[2]:gsub("*", "")).StudsPerTileU
                            tempTexture.StudsPerTileV = replicatedStorage.Modules._Data.MaterialData.Textures:FindFirstChild(colorTable[2]:gsub("*", "")).StudsPerTileV
                            tempTexture.Transparency = 0
                        end
                    end
                end)
            end, function(a, b)
                warn("Hologram Error: (Report to Hold#4564) Details:", a, b)
            end)
        end
        local function placeObject(name, parent)
            local clonedObject = data.items:FindFirstChild(name, 1):Clone()
            clonedObject.Parent = parent
    
            for _, descendant in next, clonedObject:GetDescendants() do
                if descendant:IsA("BasePart") then
                    descendant.CanCollide = false
                    if descendant.Transparency < 1 then
                        descendant.Transparency = settings.ObjectTransparency
                    end
                end
            end
    
            return clonedObject
        end
        local function canBeSplitted(name)
            return data.items.Windows:FindFirstChild(name) or data.items["Wall Trim"]:FindFirstChild(name) or data.items.Doors:FindFirstChild(name) or false
        end
        local function replicateObject(object)
            local part = Instance.new("Part", object.Parent)
    
            part.Name = object.Name
            part.CFrame = object.PrimaryPart.CFrame
            part.Size = object.PrimaryPart.Size
    
            local objectModel = Instance.new("Model", part)
            
            objectModel.Name = "ObjectModel"
    
            for _, descendant in next, object:GetChildren() do
                if descendant.ClassName:find("Part") then
                    descendant:Clone().Parent = objectModel
                end
            end
    
            return part
        end
        local function placeObjects(clone, roof)
            if not roof.Objects then
                return
            end
    
            local itemHolder = Instance.new("Folder", clone)
            itemHolder.Name = "ItemHolder"
    
            for _, object in next, roof.Objects do
                local objectClone = placeObject(object.Name, itemHolder)
    
                if objectClone:IsA("Model") then
                    objectClone:SetPrimaryPartCFrame(loadCFrame(object.CFrame))
                    objectClone.PrimaryPart.Anchored = true
                else
                    objectClone.CFrame = loadCFrame(object.CFrame)
                    objectClone.Anchored = true
                end
    
                if object.Image and objectClone:FindFirstChild("Canvas1", 1) then
                    objectClone:FindFirstChild("Canvas1", 1):FindFirstChildOfClass("Decal").Texture = "rbxassetid://" .. object.Image
                end
    
                if not object.Color then
                    continue
                end
    
                for colorIndex, colorTable in next, object.Color do
                    if not colorTable[1] or not objectClone:FindFirstChild("ColorGroup" .. colorIndex) then
                        continue
                    end
                    for innerColorIndex, innerColorTable in next, objectClone["ColorGroup" .. colorIndex]:GetChildren() do
                        if innerColorTable:IsA("ObjectValue") and innerColorTable.Value then
                            colorPart(innerColorTable.Value, colorTable)
                        end
                    end
                end
    
                if object.Objects then
                    placeObjects(objectClone, object)
                end
            end
        end
        local function createDictionary(name)
            local folder = Instance.new("Folder", previewFolder)
            folder.Name = name
    
            return folder
        end
        local function replaceLevelFromCFrame(cframe, levelType, level)
            local cframeClone = {cframe:components()}
            for _ = 1, 3 do
                table.remove(cframeClone, 1)
            end
    
            if levelType == "X" then
                return CFrame.new(level, cframe.Y, cframe.Z, unpack(cframeClone))
            elseif levelType == "Y" then
                return CFrame.new(cframe.X, level, cframe.Z, unpack(cframeClone))
            elseif levelType == "Z" then
                return CFrame.new(cframe.X, cframe.Y, level, unpack(cframeClone))
            end
    
            return false
        end
        
        -- create dicts
        do
            createDictionary("Walls")
            createDictionary("Roofs")
            createDictionary("Floors")
            createDictionary("Paths")
            createDictionary("Objects")
            createDictionary("Counters")
            createDictionary("Fences")
            createDictionary("Pools")
            createDictionary("Basements")
        end
        
        -- pole added connection
        local poleConnectionAdded = targetPlot.House.Walls.Poles.ChildAdded:Connect(function(poleConnection)
            poleConnection:Destroy()
        end)
    
        -- preview start
        do
            for _, wall in next, loadData.Walls do
                task.spawn(function()
                    local wallClone = modules.wallService:BuildWall(targetPlot, "Wall", loadPosition(wall.Position.From), loadPosition(wall.Position.To))
                    wallClone.Parent = previewFolder.Walls
        
                    local hookType = true
        
                    if wall.Objects then
                        wallClone.RPart.Transparency = Settings.WallTransparency
                        wallClone.LPart.Transparency = Settings.WallTransparency
                    end
        
                    if wall.Color then
                        if wall.Color.Right then
                            colorPart(wallClone.RPart, wall.Color.Right)
                        end
                        if wall.Color.Left then
                            colorPart(wallClone.LPart, wall.Color.Left)
                        end
                    end
                    
                    if wall.Objects then
                        local itemHolder = Instance.new("Folder", wallClone)
                        itemHolder.Name = "ItemHolder"
            
                        for _, object in next, wall.Objects do
                            local objectClone = placeObject(object.Name, itemHolder)   
                            objectClone:SetPrimaryPartCFrame(loadCFrame(object.CFrame))
        
                            if object.Image and objectClone:FindFirstChild("Canvas1", 1) then
                                objectClone:FindFirstChild("Canvas1", 1):FindFirstChildOfClass("Decal").Texture = "rbxassetid://"..object.Image
                            end
                
                            for colorIndex, colorTable in next, object.Color do
                                if not colorTable[1] then
                                    continue
                                end
                                for innerColorIndex, innerColorTable in next, objectClone["ColorGroup" .. colorIndex]:GetChildren() do
                                    if innerColorTable:IsA("ObjectValue") and innerColorTable.Value then
                                        colorPart(innerColorTable.Value, colorTable)
                                    end
                                end
                            end
        
                            local objectType = allItems:GetItemFromObject(objectClone).Type
                            if objectType == "Windows" then
                                local glass = objectClone:FindFirstChild("Glass", 1)
                                if glass then
                                    glass.Transparency = 0.9
                                elseif objectClone.Origin.Transparency == 0 then
                                    objectClone.Origin.Transparency = 0.9
                                end
                            elseif objectType == "Doors" and objectClone:FindFirstChild("Glass", 1) then
                                objectClone:FindFirstChild("Glass", 1).Transparency = 0.9
                            end
                        end
                    end
                    
                    local oldIsType = modules.typeService.ObjectIsAnyType
                    modules.typeService.ObjectIsAnyType = function(funcs, part, ...)
                        if hookType then
                            local canSplit = canBeSplitted(part.Name)
                            return canSplit and canSplit.Parent.Name or false
                        end
                        return oldIsType(funcs, part, ...)
                    end
        
                    if wallClone:FindFirstChild("ItemHolder") then
                        local savedObjects = {}
                        for _, object in next, wallClone.ItemHolder:GetChildren() do
                            table.insert(savedObjects, object:Clone())
                        end
                        wallClone.ItemHolder:ClearAllChildren()
        
                        for _, object in next, savedObjects do
                            replicateObject(object:Clone()).Parent = wallClone.ItemHolder
                        end
        
                        modules.wallService.UpdateWallOpenings(nil, wallClone, wall.ItemHolder, nil, nil, nil, true)
        
                        wallClone.ItemHolder:ClearAllChildren()
        
                        for _, object in next, savedObjects do
                            object.Parent = wallClone.ItemHolder
                        end
                    end
        
                    hookType = false
                end)
            end
            for _, roof in next, loadData.Roofs do
                for index, point in pairs(roof.Points) do
                    roof.Points[index] = loadPosition(point)
                end
                roof.Settings.IsPreview = false
                roof.Settings.RotateNum = 0
        
                local roofClone = modules.roofService:CreateRoof(targetPlot, roof.Points, roof.Settings)        
                if not roofClone or not roofClone.Model then
                    continue
                end
                roofClone.Model.Name = roof.Settings.Type
                roofClone.Model.Parent = previewFolder.Roofs
                for _, descendant in next, roofClone.Model:GetDescendants() do
                    if descendant:IsA("BasePart") then
                        descendant.CanCollide = true
                        descendant.Transparency = 0
                    end
                end
    
                for colorIndex, colorTable in next, roof.Color do
                    if not colorTable[1] then
                        continue
                    end
                    for innerColorIndex, innerColorTable in next, roofClone.Model["ColorGroup" .. colorIndex]:GetChildren() do
                        if innerColorTable:IsA("ObjectValue") and innerColorTable.Value then
                            colorPart(innerColorTable.Value, colorTable)
                        end
                    end
                end
    
                placeObjects(roofClone.Model, roof)
            end
            for _, floor in next, loadData.Floors do
                for index, point in pairs(floor.Points) do
                    floor.Points[index] = loadPosition(point)
                end
        
                local upVectors = {}
                local downVectors = {}
    
                for _, point in next, floor.Points do
                    table.insert(upVectors, Vector3.new(point.X, point.Y + 0.1, point.Z))
                end
                for _, point in next, floor.Points do
                    table.insert(downVectors, Vector3.new(point.X, point.Y - 0.1, point.Z))
                end
        
                local floorClone = Instance.new("Model", previewFolder.Floors)
                floorClone.Name = "FloorModel"
        
                local upperPoints, downPoints = modules.polygon:fromPoints(upVectors), modules.polygon:fromPoints(downVectors)
                local upFloors = upperPoints:Fill(function(a, b)
                    a.Transparency = settings.FloorTransparency
                    a.Size = Vector3.new(0.25, a.Size.Y, a.Size.Z)
                    a.CFrame = a.CFrame
                    a.Parent = b
                    a.CanCollide = false
                    a.Name = "Upper"
                end, floorClone)
                local downFloors = downPoints:Fill(function(a, b)
                    a.Transparency = settings.FloorTransparency
                    a.Size = Vector3.new(0.25, a.Size.Y, a.Size.Z)
                    a.CFrame = a.CFrame
                    a.Parent = b
                    a.CanCollide = false
                    a.Name = "Lower"
                end, floorClone)
        
                for _, floorPart in next, upFloors do
                    if floor.Color and floor.Color[1] then
                        colorPart(floorPart, floor.Color[1])
                    end
                end
                for _, floorPart in next, downFloors do
                    if floor.Color and floor.Color[1] then
                        colorPart(floorPart, floor.Color[1])
                    end
                end
            end
            for _, path in next, loadData.Paths do
                local distance = (loadPosition(path.From) - loadPosition(path.To)).Magnitude
                local pathModel = Instance.new("Model", previewFolder.Paths)
        
                local from, to = loadPosition(path.From), loadPosition(path.To)
                local distance = (from - to).Magnitude
                local middlePart = replicatedStorage.GameObjects.WallGroup.MPart 
                local lenY = middlePart.Size.Y
                local lenX = middlePart.Size.X
        
                local item1 = newGhost({
                    Size = Vector3.new(lenX, lenY, distance),
                    CFrame = CFrame.new(from, to) * CFrame.new(0, 0, - distance / 2) * CFrame.new(-0.125, 0, 0),
                    Size = Vector3.new(4.5, 0.05, distance),
                    TopSurface = "Smooth"
                })
                local item2 = newGhost({
                    Size = Vector3.new(lenX, lenY, distance),
                    Position = loadPosition(path.From),
                    Size = Vector3.new(0.05, 4.5, 4.5),
                    TopSurface = "Smooth",
                    Shape = Enum.PartType.Cylinder
                })
                local item3 = newGhost({
                    Size = Vector3.new(lenX, lenY, distance),
                    Position = loadPosition(path.To),
                    Size = Vector3.new(0.05, 4.5, 4.5),
                    TopSurface = "Smooth",
                    Shape = Enum.PartType.Cylinder
                })
        
                item2.Rotation = Vector3.new(0, 0, 90)
                item3.Rotation = Vector3.new(0, 0, 90)
    
                item1.Parent = pathModel
                item2.Parent = pathModel
                item3.Parent = pathModel
        
                item1.Transparency = settings.PathTransparency
                item2.Transparency = settings.PathTransparency
                item3.Transparency = settings.PathTransparency
        
                if path.Color[1] then
                    colorPart(item1, path.Color[1])
                    colorPart(item2, path.Color[1])
                    colorPart(item3, path.Color[1])
                end
            end
            for _, object in next, loadData.Objects do
                local objectClone = placeObject(object.Name, previewFolder.Objects)
            
                if objectClone:IsA("Model") then
                    objectClone:SetPrimaryPartCFrame(object.TransformData and loadCFrame(object.TransformData) or loadCFrame(object.CFrame))
                else
                    objectClone.CFrame = object.TransformData and decode.cframe(object.TransformData) or loadCFrame(object.CFrame)
                end
                local light = objectClone:FindFirstChild("Light")
        
                for colorIndex, colorTable in next, object.Color do
                    if not colorTable[1] then
                        continue
                    end
                    for innerColorIndex, innerColorTable in next, objectClone["ColorGroup" .. colorIndex]:GetChildren() do
                        if innerColorTable:IsA("ObjectValue") and innerColorTable.Value then
                            colorPart(innerColorTable.Value, colorTable)
                        end
                    end
                end
        
                if object.ResizeData then
                    -- soon
                end
                if light then
                    light.Color = Color3.fromRGB(255, 255, 255)
                    for _, light in next, light:GetChildren() do
                        if light.ClassName:find("Light") then
                            light.Color = Color3.fromRGB(255, 255, 255)
                        end
                    end
                end
    
                if object.Image and objectClone:FindFirstChild("Canvas1", 1) then
                    objectClone:FindFirstChild("Canvas1", 1):FindFirstChildOfClass("Decal").Texture = "rbxassetid://" .. object.Image
                end
        
                placeObjects(objectClone, object)
            end
            for _, counter in next, loadData.Counters do
                local counterClone = placeObject(counter.Name, previewFolder.Objects)
            
                if counterClone:IsA("Model") then
                    counterClone:SetPrimaryPartCFrame(loadCFrame(counter.CFrame))
                else
                    counterClone.CFrame = loadCFrame(counter.CFrame)
                end
        
                for colorIndex, colorTable in next, counter.Color do
                    if not colorTable[1] then
                        continue
                    end
                    for innerColorIndex, innerColorTable in next, counterClone["ColorGroup" .. colorIndex]:GetChildren() do
                        if innerColorTable:IsA("ObjectValue") and innerColorTable.Value then
                            colorPart(innerColorTable.Value, colorTable)
                        end
                    end
                end
        
                placeObjects(counterClone, counter)
            end
            for _, basement in next, loadData.Basements do
                local basementModel = Instance.new("Model", targetPlot.House.Basements)
                basementModel.Name = "Basement"
    
                local item = newGhost({
                    CFrame = loadCFrame(basement.Center),
                    Size = Vector3.new(basement.Size[1], 1, basement.Size[2]),
                    Name = "HitBox",
                    Transparency = 1,
                    Parent = basementModel
                })
    
                basementModel.PrimaryPart = item
    
                table.insert(toVanish, {
                    type = "Basements",
                    object = basementModel
                })
            end
            for _, pool in next, loadData.Pools do
                local poolModel = Instance.new("Model", targetPlot.House.Pools)
                poolModel.Name = pool.Name
    
                local poolCFrame = loadCFrame(pool.Center)
                local sizeYLevel = (pool.Name == "Classic Pool" and 3.5) or (pool.Name == "Shallow Pool" and 8) or (pool.Name == "Deep Pool" and 0.5)
                local positionYLevel = (pool.Name == "Classic Pool" and 10.75) or (pool.Name == "Shallow Pool" and 13) or (pool.Name == "Deep Pool" and 9.25)
    
                local hitbox = newGhost({
                    CFrame = poolCFrame,
                    Size = Vector3.new(pool.Size[1], 1, pool.Size[2]),
                    Name = "HitBox",
                    Transparency = 1,
                    Parent = poolModel
                })
                local waterEnd = newGhost({
                    CFrame = replaceLevelFromCFrame(poolCFrame, "Y", positionYLevel),
                    Size = Vector3.new(pool.Size[1], sizeYLevel, pool.Size[2]),
                    Name = "WaterEnd",
                    Transparency = 0,
                    Parent = poolModel
                })
                colorPart(waterEnd, pool.Color[1])
    
                table.insert(toVanish, {
                    type = "Pools",
                    object = poolModel
                })
    
                placeObjects(poolModel, pool)
            end
            for _, fence in next, loadData.Fences do
                local item = modules.fenceService.Items:GetItemFromObject(replicatedStorage.Modules["_Objects"].FenceService[fence.Name])
                local fenceClone = (modules.fenceService:GetUpdateFunction(targetPlot, modules.fenceService:SetupFenceOrigin(item, loadPosition(fence.From), loadPosition(fence.To))))()
                fenceClone.Parent = previewFolder.Fences
        
                if fenceClone:IsA("Model") then
                    for colorIndex, colorTable in next, fence.Color do
                        if not colorTable[1] then
                            continue
                        end
                        for innerColorIndex, innerColorTable in next, fenceClone["ColorGroup" .. colorIndex]:GetChildren() do
                            if innerColorTable:IsA("ObjectValue") and innerColorTable.Value then
                                colorPart(innerColorTable.Value, colorTable)
                            end
                        end
                    end
                else
                    ColorPart(fenceClone, fence.Color[1])
                end
    
                placeObjects(fenceClone, fence)
            end
        end
    
        -- finishing
        poleConnectionAdded:Disconnect()
        modules.groundService.Update(targetPlot, targetPlot)
        for _, vanishObject in next, toVanish do
            vanishObject.object.Parent = previewFolder[vanishObject.type]
        end
        previewFolder.Parent = workspace
    
        notification.sideNotify("Holograms are still in beta,\nif you entcounter any bugs,\nmake sure to report them to\n" .. discordData.discord_username)
    end)
    ui.pages.autoBuild.sections.load:Button("Destroy Hologram", function()
        local targetPlot = clientStats.IsBuilding.Value
    
        for _, child in next, workspace:GetChildren() do
            if child.Name == "Bloxburger_Preview" then
                child:Destroy()
            end
        end
    
        task.wait()
        modules.groundService.Update(targetPlot, targetPlot)
    end)
end

-- auto farm
do
    -- sections
    ui.pages.autoFarm.sections = {}

    ui.pages.autoFarm.sections.main = ui.pages.autoFarm:Section("Main")
    ui.pages.autoFarm.sections.stats = ui.pages.autoFarm:Section("Stats")
    ui.pages.autoFarm.sections.quitSettings = ui.pages.autoFarm:Section("Job Quit Settings")
    ui.pages.autoFarm.sections.gameSettings = ui.pages.autoFarm:Section("Game Settings")

    -- main elements
    ui.pages.autoFarm.sections.main:Dropdown("Select Job", data.jobData.jobValues, function(d)
        featureConfig.autoFarm.selectedJob = data.jobData.jobNames[d]
    end)
    ui.pages.autoFarm.sections.main:Button("Goto Job", function()
        if not featureConfig.autoFarm.selectedJob then
            return notification.sideNotify("Error, you have no job selected.")
        end
        for _ = 1, 3 do
            task.spawn(function()
                network:InvokeServer({
                    Type = "ToWork",
                    Name = featureConfig.autoFarm.selectedJob
                })
            end)
        end
    end)
    ui.pages.autoFarm.sections.main:Button("Force Shift End", function()
        local oldPos = localPlayer.Character.HumanoidRootPart.CFrame

        localPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(oldPos.X, 100000, oldPos.Z)
        libraries.utilities:GetRoot().Anchored = true

        network:FireServer({
            Type = "EndShift",
        })

        libraries.utilities:GetRoot().Anchored = false
        localPlayer.Character.HumanoidRootPart.CFrame = oldPos
    end)
    ui.pages.autoFarm.sections.main:Line()
    ui.pages.autoFarm.sections.main.enabled = ui.pages.autoFarm.sections.main:Toggle("Enabled", false, function(t)
        if not featureConfig.autoFarm.selectedJob and t then
            task.spawn(function()
                task.wait(0.2)
                ui.pages.autoFarm.sections.main.enabled:Toggle(false)
            end)
            return notification.sideNotify("Error, you have no job selected.")
        end
        bloxburger.jobs.autoFarmEnabled = t
    end)
    ui.pages.autoFarm.sections.main:Toggle("Realistic Mode", false, function(t)
        bloxburger.jobs.realisticMode = t
    end)

    ui.pages.autoFarm.sections.stats.shiftEarnings = ui.pages.autoFarm.sections.stats:DoubleLabel("Shift Earnings", "$0", Color3.fromRGB(0, 212, 0))
    ui.pages.autoFarm.sections.stats.shiftDuration = ui.pages.autoFarm.sections.stats:DoubleLabel("Shift Duration", "0s", Color3.fromRGB(212, 212, 212))
    ui.pages.autoFarm.sections.stats.jobLevel = ui.pages.autoFarm.sections.stats:ReadOnly("Job Level", {
        minValue = 0,
        maxValue = 50,
        currentValue = 1
    })
    ui.pages.autoFarm.sections.stats.jobPromotion = ui.pages.autoFarm.sections.stats:ReadOnly("Job Promotion", {
        minValue = 0,
        maxValue = 100,
        currentValue = 1
    })

    -- quit setting elements
    ui.pages.autoFarm.sections.quitSettings:Toggle("Stop after Goal", false, function(t)
        featureConfig.autoFarm.shouldStop = t
        if t == true then
            notification.sideNotify("As soon as the auto farm hit the goal, you specified in the stop method settings, the game will automatically shut down.")
        end
    end)
    ui.pages.autoFarm.sections.quitSettings:Dropdown("Stop Method", {"Money", "Seconds"}, function(d)
        featureConfig.autoFarm.stopMethod = d
    end)
    ui.pages.autoFarm.sections.quitSettings:Textbox("Enter Money", "Stop after Money", function(t)
        featureConfig.autoFarm.stopMoney = tonumber(t)
    end)
    ui.pages.autoFarm.sections.quitSettings:Textbox("Enter Seconds", "Amount in Seconds", function(t)
        featureConfig.autoFarm.stopSeconds = tonumber(t)
    end)

    -- game settings
    ui.pages.autoFarm.sections.gameSettings:Toggle("Anti Job Kick", false, function(t)
        featureConfig.autoFarm.antiJobKick = t
        if t == true then
            notification.sideNotify("This will disable, when you leave the job area that you still keep your job.")
        end
    end)

    -- count seconds
    task.spawn(function()
        while task.wait() do
            if modules.jobManager:GetJob() then
                featureConfig.autoFarm.currentTick = tick()
                repeat
                    task.wait()
                until not modules.jobManager:GetJob()
            end
        end
    end)
    -- stop loop
    task.spawn(function()
        while task.wait(0.5) do
            if featureConfig.autoFarm.shouldStop and modules.jobManager:GetJob() then
                local money, seconds = functions.stats.getShiftInfo()
                if featureConfig.autoFarm.stopMethod == "Money" then
                    if money >= featureConfig.autoFarm.stopMoney then
                        pcall(function()
                            game:Shutdown()
                        end)
                        task.wait(1)
                        while true do end
                    end
                elseif featureConfig.autoFarm.stopMethod == "Seconds" then
                    if (featureConfig.autoFarm.currentTick + featureConfig.autoFarm.stopSeconds) <= tick() then
                        pcall(function()
                            game:Shutdown()
                        end)
                        task.wait(1)
                        while true do end
                    end
                end
            end
        end
    end)

    -- stop after job
    task.spawn(function()
        while task.wait() do
            if mainUi.Bar.CharMenu.WorkFrame.WorkFrame.Visible then
                local money, time = functions.stats.getShiftInfo()
                local level, current, goal = functions.stats.getJobProgress()

                ui.pages.autoFarm.sections.stats.shiftEarnings:Text(("$%s"):format(beautifyMoney(money)))
                ui.pages.autoFarm.sections.stats.shiftDuration:Text(("%s"):format(time))
                ui.pages.autoFarm.sections.stats.jobLevel:Update({
                    minValue = 0,
                    maxValue = 50,
                    currentValue = level
                })
                ui.pages.autoFarm.sections.stats.jobPromotion:Update({
                    minValue = 0,
                    maxValue = goal,
                    currentValue = current
                })
            else
                ui.pages.autoFarm.sections.stats.shiftEarnings:Text("0$")
                ui.pages.autoFarm.sections.stats.shiftDuration:Text("0s")
                ui.pages.autoFarm.sections.stats.jobLevel:Update({
                    minValue = 0,
                    maxValue = 50,
                    currentValue = 0
                })
                ui.pages.autoFarm.sections.stats.jobPromotion:Update({
                    minValue = 0,
                    maxValue = 100,
                    currentValue = 0
                })
            end
        end
    end)

    -- auto farms
    do
        -- delivery
        task.spawn(function()
            while task.wait() do
                if featureConfig.autoFarm.currentJob == "PizzaPlanetDelivery" and bloxburger.jobs.autoFarmEnabled and featureConfig.autoFarm.selectedJob == "PizzaPlanetDelivery" then
                    -- delivery functions
                    local function getPizzaPlanet()
                        workspace.Environment.Locations:WaitForChild("PizzaPlanet"):WaitForChild("Conveyor"):WaitForChild("MovingBoxes")
                        return workspace.Environment.Locations.PizzaPlanet, workspace.Environment.Locations.PizzaPlanet.Conveyor.MovingBoxes
                    end
                    local function getPizza(pizzas, root)
                        local customer
                        repeat
                            for _, pizza in next, pizzas:GetChildren() do
                                if root then
                                    root.CFrame = CFrame.new(pizza.Position.X, 5, pizza.Position.Z) * CFrame.Angles(0, math.rad(180), 0)
                                end
                                customer = network:InvokeServer({
                                    Type = "TakePizzaBox",
                                    Box = pizza
                                })
                                if customer then
                                    break
                                end
                                task.wait(0.05)
                            end
                            if customer then
                                continue
                            end
                            task.wait(0.05)
                        until customer
                        return customer
                    end
                    local function press(letter)
                        virtualInputManager:SendKeyEvent(true, Enum.KeyCode[string.upper(letter)], false, nil)
                    end
                    local function release(letter)
                        virtualInputManager:SendKeyEvent(false, Enum.KeyCode[string.upper(letter)], false, nil)
                    end
                    -- local degree = 0
                    -- local function rotateRoot(partToRotate, center)
                    --     local angle = CFrame.Angles(0, -math.rad(degree) ,0)
                    --     local offset = CFrame.new(0,0,5) -- where the part is from the center
                    --     local rotatedCFrame = CFrame.new(center) * angle * offset
                    --     partToRotate.CFrame = rotatedCFrame
                    --     degree += 0.1
                    -- end
                    -- local t = 0
                    -- local function circle(a)
                    --     a.CFrame += Vector3.new(math.sin(t), 0, math.cos(t))
                    --     t += 0.01
                    -- end

                    if not bloxburger.jobs.realisticMode then
                        -- get moped
                        local moped
                        repeat
                            moped = network:InvokeServer({Type = "UsePizzaMoped"})
                            task.wait(0.1)
                        until moped
                        
                        -- loading pizza planet
                        local pizzaPlanet, pizzas = getPizzaPlanet()
                        
                        -- modding moped
                        moped:WaitForChild("Body")
                        if not moped.PrimaryPart then
                            moped.PrimaryPart = moped.Body
                        end
                        moped.PrimaryPart:ClearAllChildren()
                        local velocity = Instance.new("BodyVelocity", moped.PrimaryPart)
                        velocity.MaxForce = Vector3.inf
                        velocity.P = 35
                        velocity.Velocity = Vector3.zero
                        task.wait()
                        for _, animation in next, humanoid:GetPlayingAnimationTracks() do
                            local animationName = tostring(animation) or animation.Name
                            if animationName == "SitAnim" or animationName == "RideMoped" then
                                animation:Stop()
                            end
                        end

                        -- get customer
                        local customer = getPizza(pizzas, moped.PrimaryPart)
                        customer:WaitForChild("HumanoidRootPart")

                        -- moving to destination
                        local xzCustomerPosition
                        local xzHeartPosition

                        moped.PrimaryPart.CFrame = CFrame.new(moped.PrimaryPart.Position.X, -50, moped.PrimaryPart.Position.Z)
                        task.wait()
                        repeat
                            xzCustomerPosition = Vector3.new(customer.HumanoidRootPart.Position.X, 0, customer.HumanoidRootPart.Position.Z)
                            xzHeartPosition = Vector3.new(moped.PrimaryPart.Position.X, 0, moped.PrimaryPart.Position.Z)

                            local calculated = (customer.HumanoidRootPart.Position -  moped.PrimaryPart.Position).Unit * 32

                            velocity.Velocity = Vector3.new(calculated.X, 0, calculated.Z)
                            task.wait()
                        until (xzHeartPosition - xzCustomerPosition).Magnitude <= 5
                        velocity.Velocity = Vector3.zero
                        task.wait(0.1)

                        -- delivering pizza
                        repeat
                            local xzCustomerPosition = Vector3.new(customer.HumanoidRootPart.Position.X, customer.HumanoidRootPart.Position.Y - 8.5, customer.HumanoidRootPart.Position.Z)
                            moped.PrimaryPart.CFrame = CFrame.new(xzCustomerPosition)
                            network:FireServer({
                                Type = "DeliverPizza",
                                Customer = customer
                            })
                            task.wait(0.1)
                        until not character:FindFirstChild("Pizza Box")

                        -- unmodding moped
                        moped.PrimaryPart:ClearAllChildren()

                        -- getting back
                        if not bloxburger.jobs.PizzaPlanetDelivery.Enabled then
                            local moped
                            repeat
                                moped = network:InvokeServer({Type = "UsePizzaMoped"})
                                task.wait(0.1)
                            until moped
                        end
                    elseif bloxburger.jobs.realisticMode then
                        -- going to pizza station
                        if localPlayer:DistanceFromCharacter(Vector3.new(1166, 14, 278)) > 25 then
                            repeat
                                task.spawn(function()
                                    network:InvokeServer({
                                        Type = "ToWork",
                                        Name = "PizzaPlanetDelivery"
                                    })
                                end)
                                task.wait(0.1)
                            until localPlayer:DistanceFromCharacter(Vector3.new(1166, 14, 278)) < 20
                        end

                        -- loading pizza planet
                        local pizzaPlanet, pizzas = getPizzaPlanet()

                        -- go to pizzas
                        functions.teleportation.pathfind(Vector3.new(math.random(1167, 1173), 14, math.random(273, 274)))

                        -- take pizza
                        local customer = getPizza(pizzas)
                        customer:WaitForChild("HumanoidRootPart")

                        -- taking moped
                        functions.teleportation.pathfind(functions.utilities.randomPosition(Vector3.new(1172, 14, 287)))
                        local moped
                        repeat
                            moped = network:InvokeServer({Type = "UsePizzaMoped"})
                            task.wait(0.1)
                        until moped
                        moped:WaitForChild("Body")

                        -- modding moped
                        moped.Body:WaitForChild("BodyVelocity").Parent = nil
                        local velocity = Instance.new("BodyVelocity", moped.Body)
                        velocity.MaxForce = Vector3.new(9e9, 250, 9e9)
                        velocity.P = 35
                        velocity.Velocity = Vector3.zero

                        -- creating path
                        local pathThere = pathfindingService:CreatePath({
                            AgentRadius = 4,
                            AgentHeight = 5,
                            WaypointSpacing = 2,
                            AgentCanJump = true,
                            Costs = {
                                Water = math.huge,
                                Pavement = 10,
                                Terrain = 9e9,
                                Road = 0.001,
                                IgnoreArea = 9e9,
                                PizzaRing = 9e9
                            }
                        })
                        pathThere:ComputeAsync(humanoidRootPart.Position, customer.HumanoidRootPart.Position)
                        local pathThereWaypoints = pathThere:GetWaypoints()

                        -- checks
                        if #pathThereWaypoints == 0 then
                            pathThere = pathfindingService:CreatePath({
                                AgentRadius = 4,
                                AgentHeight = 5,
                                WaypointSpacing = 2,
                                AgentCanJump = true,
                                Costs = {
                                    Water = math.huge,
                                    Pavement = 10,
                                    Terrain = 100,
                                    Road = 0.001,
                                    PizzaRing = 9e9
                                }
                            })
                            pathThere:ComputeAsync(humanoidRootPart.Position, customer.HumanoidRootPart.Position)
                            pathThereWaypoints = pathThere:GetWaypoints()

                            notification.sideNotify("Failed creating path, trying a other path.")
                        end

                        -- going to customer
                        for _, waypoint in next, pathThereWaypoints do
                            moped:WaitForChild("Body")
                            local cframe = {(CFrame.lookAt(
                                moped.Body.Position,
                                Vector3.new(waypoint.Position.X, moped.Body.Position.Y, waypoint.Position.Z)
                            )):components()}
                            for _ = 1, 3 do
                                table.remove(cframe, 1)
                            end
                            local tween = tweenObject(moped.Body, 0.025, {
                                CFrame = CFrame.new(moped.Body.Position.X, moped.Body.Position.Y, moped.Body.Position.Z, unpack(cframe))
                            }).Completed:Wait()
                            
                            local startInit = tick()
                            repeat
                                velocity.Velocity = (Vector3.new(waypoint.Position.X, moped.Body.Position.Y, waypoint.Position.Z) - moped.Body.Position).Unit * 35
                                task.wait()
                            until (moped.Body.Position - waypoint.Position).Magnitude <= 5.5 or (tick() - startInit) > 1
                            velocity.Velocity = Vector3.zero

                            if (tick() - startInit) > 1 then
                                moped.Body.CFrame = CFrame.new(waypoint.Position)
                            end
                        end

                        -- delivering pizza
                        task.wait(tonumber("0." .. math.random(3, 6)))
                        repeat
                            network:FireServer({
                                Type = "DeliverPizza",
                                Customer = customer
                            })
                            task.wait(0.1)
                        until not character:FindFirstChild("Pizza Box")

                        -- delay for legitness
                        task.wait(tonumber("1." .. math.random(3, 8)))

                        -- going back
                        reverseTable(pathThereWaypoints)
                        for _ = 1, 3 do
                            table.remove(pathThereWaypoints, #pathThereWaypoints)
                        end

                        tweenObject(moped.Body,  0.6 + randomOneDecimalNumber(), {
                            CFrame = moped.Body.CFrame * CFrame.Angles(0, math.rad(180), 0)
                        }).Completed:Wait()
                        task.wait(0.1 + randomOneDecimalNumber())
                        -- local customerSavedPosition = moped.Body.Position
                        -- for radius = 1, 30 do
                        --     circle(moped.Body, customerSavedPosition)
                        --     task.wait(0.01)
                        -- end

                        for _, waypoint in next, pathThereWaypoints do
                            moped:WaitForChild("Body")
                            local cframe = {(CFrame.lookAt(
                                moped.Body.Position,
                                Vector3.new(waypoint.Position.X, moped.Body.Position.Y, waypoint.Position.Z)
                            )):components()}
                            for _ = 1, 3 do
                                table.remove(cframe, 1)
                            end
                            local tween = tweenObject(moped.Body, 0.025, {
                                CFrame = CFrame.new(moped.Body.Position.X, moped.Body.Position.Y, moped.Body.Position.Z, unpack(cframe))
                            }).Completed:Wait()
                            
                            local startInit = tick()
                            repeat
                                velocity.Velocity = (Vector3.new(waypoint.Position.X, moped.Body.Position.Y, waypoint.Position.Z) - moped.Body.Position).Unit * 35
                                task.wait()
                            until (moped.Body.Position - waypoint.Position).Magnitude <= 5.5 or (tick() - startInit) > 1
                            velocity.Velocity = Vector3.zero

                            if (tick() - startInit) > 1 then
                                moped.Body.CFrame = CFrame.new(waypoint.Position)
                            end
                        end

                        network:FireServer({
                            Type = "Detach"
                        })
                        
                        if bloxburger.jobs.PizzaPlanetDelivery.Enabled then
                            task.wait(tonumber("1." .. math.random(3, 8)))
                        end
                    end
                end
            end
        end)

        -- ice cream
        task.spawn(function()
            while task.wait() do
                if featureConfig.autoFarm.currentJob == "BensIceCreamSeller" and bloxburger.jobs.autoFarmEnabled and featureConfig.autoFarm.selectedJob == "BensIceCreamSeller" then
                    -- get current customer
                    local currentCustomer
                    for _, customer in next, data.customers:GetChildren() do
                        if customer.Name == "BensIceCreamCustomer" and customer:FindFirstChild("Order") and customer:FindFirstChild("HumanoidRootPart") and customer.HumanoidRootPart:FindFirstChild("Motor6D") then
                            if customer.HumanoidRootPart.Motor6D.Part1 then
                                currentCustomer = customer
                                break
                            end
                        end
                    end
                    if not currentCustomer then
                        continue
                    end

                    -- getting cup
                    functions.teleportation.jobTeleport(Vector3.new(929, 14, 1049), true)
                    while not modules.equipmentService:GetEquipped(localPlayer) do
                        network:FireServer({
                            Type = "TakeIceCreamCup"
                        })
                        task.wait(0.1)
                    end
                    local ball1, ball2
                    task.wait()

                    -- adding ice
                    functions.teleportation.jobTeleport(Vector3.new(934, 14, 1052), true)
                    network:FireServer({
                        Type = "AddIceCreamScoop",
                        Ball = character["Ice Cream Cup"]:FindFirstChild("Ball1") or character["Ice Cream Cup"]:WaitForChild("Ball1"),
                        Taste = currentCustomer.Order.Flavor1.Value
                    })
                    task.wait(0.1)
                    network:FireServer({
                        Type = "AddIceCreamScoop",
                        Ball = character["Ice Cream Cup"]:FindFirstChild("Ball2") or character["Ice Cream Cup"]:WaitForChild("Ball2"),
                        Taste = currentCustomer.Order.Flavor2.Value
                    })
                    task.wait(0.1)

                    -- adding topping
                    if currentCustomer.Order.Topping.Value ~= "" then
                        functions.teleportation.jobTeleport(Vector3.new(927, 14, 1046), true)
                        network:FireServer({
                            Type = "AddIceCreamTopping",
                            Taste = currentCustomer.Order.Topping.Value
                        })
                        task.wait(0.15)
                    else
                        task.wait(0.05)
                    end

                    -- completing order
                    functions.teleportation.jobTeleport(Vector3.new(941, 14, 1043), true)
                    network:FireServer({
                        Type = "JobCompleted",
                        Workstation = currentCustomer.HumanoidRootPart.Motor6D.Part1
                    })
                    currentCustomer.Name = "Ignore"
                end
            end
        end)

        -- fisherman
        task.spawn(function()
            while task.wait() do
                if featureConfig.autoFarm.currentJob == "HutFisherman" and bloxburger.jobs.autoFarmEnabled and featureConfig.autoFarm.selectedJob == "HutFisherman" then
                    -- tween to fisher position
                    functions.teleportation.jobTeleport(Vector3.new(1039, 12, 1090), true)

                    -- put rod in water
                    network:FireServer({
                        Type = "UseFishingRod",
                        Pos = Vector3.new(tostring(math.random(1034, 1036)) .. "." .. tostring(math.random(11111111, 999999999)), 8, tostring(math.random(1100, 1102)) .. "." .. tostring(math.random(11111111, 999999999))),
                        State = true
                    })
                    local startInit = tick()

                    -- waiting for fish
                    local fishingRod = character["Fishing Rod"]
                    fishingRod:WaitForChild("Bobber")
                    local continuePulling
                    local continueConnection continueConnection = fishingRod.Bobber:GetPropertyChangedSignal("Position"):Connect(function()
                        if fishingRod.Bobber.Position.Y == 7 then
                            continuePulling = true
                            continueConnection:Disconnect()
                        end
                    end)
                    repeat
                        task.wait()
                    until continuePulling

                    -- finishing fishing
                    network:FireServer({
                        Type = "UseFishingRod",
                        State = false,
                        Time = tick() - startInit
                    })

                    -- delay
                    if bloxburger.jobs.HutFisherman.Enabled then
                        task.wait(tonumber("1." .. tostring(math.random(4, 7))) + (bloxburger.jobs.realisticMode and 2.25 or 0))
                    end
                end
            end
        end)

        -- miner
        task.spawn(function()
            while task.wait() do
                if featureConfig.autoFarm.currentJob == "CaveMiner" and bloxburger.jobs.autoFarmEnabled and featureConfig.autoFarm.selectedJob == "CaveMiner" then
                    -- variables
                    local blockPath = workspace.Environment.Locations["Static_MinerCave"].Folder
                    local blocksToMine = {}
                    local blockToMine
                    local isTNT = false
                    local function identifyBlock(block)
                        local block = block:IsA("Model") and block or block.Parent
                        local childs = block:GetChildren()

                        if block:FindFirstChild("B") and #childs == 1 and block.B:FindFirstChildOfClass("Decal") and block.B:FindFirstChildOfClass("Decal").Texture == "rbxassetid://2605891245" then
                            return "TNT"
                        elseif block:FindFirstChild("M") and block:FindFirstChild("B") and #childs == 2 and block.M.Color == Color3.fromRGB(160, 95, 53) then
                            return "Copper"
                        elseif #childs == 1 and block:FindFirstChild("B") and block.B.Color == Color3.fromRGB(99, 95, 98) then
                            return "Stone"
                        else
                            return false
                        end
                    end

                    -- get block
                    for _, block in next, blockPath:GetChildren() do
                        local identify = identifyBlock(block)

                        if identify then
                            table.insert(blocksToMine, {
                                block = block,
                                type = identify
                            })
                        end
                    end
                    table.sort(blocksToMine, function(a, b)
                        local a = a.block
                        local b = b.block
                        return localPlayer:DistanceFromCharacter((a.PrimaryPart or a:FindFirstChildOfClass("BasePart")).Position) < localPlayer:DistanceFromCharacter((b.PrimaryPart or b:FindFirstChildOfClass("BasePart")).Position)
                    end)
                    do
                        if bloxburger.jobs.realisticMode then
                            for _, block in next, blocksToMine do
                                if block.type ~= "TNT" then
                                    blockToMine = block.block
                                    break
                                end
                            end
                        else
                            if not blockToMine then
                                for _, block in next, blocksToMine do
                                    if block.type == "TNT" then
                                        blockToMine = block.block
                                        isTNT = true
                                        break
                                    end
                                end
                            end
                            if not blockToMine then
                                for _, block in next, blocksToMine do
                                    if block.type == "Copper" then
                                        blockToMine = block.block
                                        break
                                    end
                                end
                            end
                            if not blockToMine then
                                for _, block in next, blocksToMine do
                                    if block.type == "Stone" then
                                        blockToMine = block.block
                                        break
                                    end
                                end
                            end
                        end
                    end

                    -- block added connection
                    local hasMined = false
                    local blockAddedConnection blockAddedConnection = blockPath.ChildRemoved:Connect(function(block)
                        if block.Name == blockToMine.Name then
                            hasMined = true
                            blockAddedConnection:Disconnect()
                        end
                    end)

                    -- goto block
                    if localPlayer:DistanceFromCharacter((blockToMine.PrimaryPart or block:FindFirstChildOfClass("BasePart")).Position) > 6 then
                        functions.teleportation.jobTeleport((blockToMine.PrimaryPart or block:FindFirstChildOfClass("BasePart")).Position, true)
                    end
                    task.wait(0.1)

                    -- mine block
                    local result
                    repeat
                        if blockToMine then
                            if not bloxburger.jobs.realisticMode then
                                humanoidRootPart.CFrame = (blockToMine.PrimaryPart or block:FindFirstChildOfClass("BasePart")).CFrame
                            end
                            result = network:InvokeServer({
                                Type = "MineBlock",
                                P = Vector3.new(tonumber(string.match(blockToMine.Name, "(.+):(.+):(.+)")))
                            })
                            task.wait(0.1)
                        else
                            result = true
                        end
                    until result
                    local startInit = tick()

                    -- add static
                    humanoidRootPart.Anchored = true
                    if isTNT then
                        repeat
                            task.wait()
                        until (tick() - startInit) > 8

                        humanoidRootPart.Anchored = false
                        humanoidRootPart.CFrame = humanoidRootPart.CFrame * CFrame.new(0, 20, 0)
                        humanoidRootPart.Anchored = true
                    end

                    -- wait for finish
                    repeat
                        task.wait()
                    until hasMined == true
                    humanoidRootPart.Anchored = false

                    -- go back or continue
                    if bloxburger.jobs.CaveMiner.Enabled == false then
                        functions.teleportation.jobTeleport(Vector3.new(369, 6, 795), true)
                    else
                        task.wait(0.15)
                    end
                end
            end
        end)

        -- burger cashier
        task.spawn(function()
            while task.wait() do
                if featureConfig.autoFarm.currentJob == "BloxyBurgersCashier" and bloxburger.jobs.autoFarmEnabled and featureConfig.autoFarm.selectedJob == "BloxyBurgersCashier" then
                    -- variables
                    local burgerPath = workspace.Environment.Locations.BloxyBurgers
                    local usedWorkstations = {}

                    -- get current workstations
                    for _, workstation in next, burgerPath.CashierWorkstations:GetChildren() do
                        local uiPath = workstation.OrderDisplay.DisplayMain.CashierGUI

                        if workstation.InUse.Value == localPlayer then
                            table.insert(usedWorkstations, workstation)
                            continue
                        end
                        if uiPath.Used.Visible == false and workstation.InUse.Value == nil then
                            table.insert(usedWorkstations, workstation)
                            continue
                        end
                    end

                    -- looping through customers
                    for _, customer in next, data.customers:GetChildren() do
                        if customer.Name == "BloxyBurgersCustomer" and customer:FindFirstChild("HumanoidRootPart") and customer.HumanoidRootPart:FindFirstChild("Motor6D") and customer.HumanoidRootPart.Motor6D.Part1 and not customer:FindFirstChild("DoneVDX") then
                            -- checking if customer is pointed to our workstations
                            local currentWorkstation = false
                            for _, workstation in next, usedWorkstations do
                                if customer.HumanoidRootPart.Motor6D.Part1 == workstation.CustomerTarget and not currentWorkstation then
                                    currentWorkstation = workstation
                                end
                            end
                            if not currentWorkstation then
                                continue
                            end
                            customer:WaitForChild("Order")

                            -- finishing order
                            if bloxburger.jobs.realisticMode then
                                local assistUi = currentWorkstation.OrderDisplay.DisplayMain.CashierGUI:FindFirstChildOfClass("Frame")
                                task.wait(randomOneDecimalNumber() + 0.4)
                                fireConnections(assistUi[customer.Order.Burger.Value], "Activated")
                                if customer.Order.Fries.Value then
                                    task.wait(randomOneDecimalNumber() + 0.1)
                                    if math.random(1, 2) == 1 then
                                        task.wait(0.1)
                                    end
                                    fireConnections(assistUi["Fries"], "Activated")
                                end
                                if customer.Order.Cola.Value then
                                    task.wait(randomOneDecimalNumber() + 0.1)
                                    if math.random(1, 2) == 1 then
                                        task.wait(0.1)
                                    end
                                    fireConnections(assistUi["Cola"], "Activated")
                                end

                                task.wait(0.35)
                                fireConnections(assistUi["Done"], "Activated")
                            else
                                network:FireServer({
                                    Type = "JobCompleted",
                                    Order = {
                                        customer.Order.Burger.Value,
                                        customer.Order.Fries.Value,
                                        customer.Order.Cola.Value
                                    },
                                    Workstation = currentWorkstation
                                })
                            end

                            -- mark customer as done
                            Instance.new("BoolValue", customer).Name = "DoneVDX"
                        end
                    end

                    -- delay
                    task.wait(0.1)
                end
            end
        end)

        -- hairdresser
        task.spawn(function()
            while task.wait() do
                if featureConfig.autoFarm.currentJob == "StylezHairdresser" and bloxburger.jobs.autoFarmEnabled and featureConfig.autoFarm.selectedJob == "StylezHairdresser" then
                    -- variables
                    local hairPath = workspace.Environment.Locations.StylezHairStudio
                    local currentWorkstation
                    local currentCustomer

                    -- get current customer, even if he is pointed to an other workstation
                    for _, customer in next, data.customers:GetChildren() do
                        if customer.Name == "StylezHairStudioCustomer" and customer:FindFirstChild("HumanoidRootPart") and customer.HumanoidRootPart:FindFirstChild("AttachWeld") and customer.HumanoidRootPart.AttachWeld.Part1 and not customer:FindFirstChild("DoneVDX") then
                            local workstation = customer.HumanoidRootPart.AttachWeld.Part1.Parent.Parent
                            
                            if workstation.InUse.Value == nil then
                                currentCustomer = customer
                                currentWorkstation = workstation
                                break
                            end
                            if workstation.InUse.Value == localPlayer then
                                currentCustomer = customer
                                currentWorkstation = workstation
                                break
                            end
                        end
                    end
                    if not currentCustomer or not currentWorkstation then
                        continue
                    end

                    -- going to workstation
                    local uiPath = currentWorkstation.Mirror.HairdresserGUI
                    if uiPath.Used.Visible then
                        functions.teleportation.jobTeleport((currentWorkstation.Mat.CFrame * CFrame.new(3.5, 1, 0)).Position, true)
                    end
                    currentCustomer:WaitForChild("Order")

                    -- finishing order
                    if bloxburger.jobs.realisticMode then
                        local assets = replicatedStorage.GameObjects.JobAssets.StylezHairAssets
                        local thingsUi = uiPath:FindFirstChildWhichIsA("Frame")

                        local style = assets.Styles:FindFirstChild(currentCustomer.Order.Style.Value)
                        local color = assets.Colors:FindFirstChild(currentCustomer.Order.Color.Value)

                        local function getColor(brickColor)
                            for _, color in next, replicatedStorage.GameObjects.JobAssets.StylezHairAssets.Colors:GetChildren() do
                                if color.Value == brickColor then
                                    return color.Name
                                end
                            end
                        end

                        task.wait(0.25 + randomOneDecimalNumber())
                        repeat
                            fireConnections(thingsUi:FindFirstChild("Style").Next, "Activated")
                            task.wait(0.1 + randomOneDecimalNumber())
                        until currentCustomer:WaitForChild("PrimaryHat").Handle.Mesh.MeshId == style.Handle.Mesh.MeshId
                        task.wait(0.2 + randomOneDecimalNumber())
                        repeat
                            fireConnections(thingsUi:FindFirstChild("Color").Next, "Activated")
                            task.wait(0.1 + randomOneDecimalNumber())
                        until getColor(currentCustomer:WaitForChild("PrimaryHat").Handle.BrickColor) == currentCustomer.Order.Color.Value

                        task.wait(0.25 + randomOneDecimalNumber())
                        fireConnections(thingsUi.Done, "Activated")

                        Instance.new("BoolValue", currentCustomer).Name = "DoneVDX"
                    else
                        network:FireServer({
                            Type = "JobCompleted",
                            Order = {
                                currentCustomer.Order.Style.Value,
                                currentCustomer.Order.Color.Value
                            },
                            Workstation = currentWorkstation
                        })
                    end

                    -- delay
                    task.wait(0.1)
                end
            end
        end)

        -- baker
        task.spawn(function()
            while task.wait() do
                if featureConfig.autoFarm.currentJob == "PizzaPlanetBaker" and bloxburger.jobs.autoFarmEnabled and featureConfig.autoFarm.selectedJob == "PizzaPlanetBaker" then
                    -- variables
                    local workstationsPath = workspace.Environment.Locations.PizzaPlanet.BakerWorkstations
                    local workstations = workstationsPath:GetChildren()
                    table.sort(workstations, function(a, b)
                        local position = Vector3.new(1179, 16, 218)
                        return (position - a.CounterTop.Position).Magnitude < (position - b.CounterTop.Position).Magnitude
                    end)

                    local workstation1 = workstations[1]
                    local workstation2 = workstations[2]
                    local middlePosition

                    local workstations = {workstations[1], workstations[2]}

                    -- calculate middle position
                    local subtractVector3 = Vector3.new(5.5, 2, 0)
                    do
                        local workstation1Position = workstation1.CounterTop.CFrame - subtractVector3
                        local workstation2Position = workstation2.CounterTop.CFrame - subtractVector3
                        local distanceToEachOther = (workstation2Position.Position - workstation1Position.Position).Magnitude

                        middlePosition = workstation1Position + Vector3.new(0, 3, distanceToEachOther / 2)
                    end

                    -- go in position
                    if not bloxburger.jobs.realisticMode then
                        humanoidRootPart.CFrame = middlePosition
                    end

                    -- calculating middle crate
                    local nearestCrate = workstationsPath.Parent.IngredientCrates:GetChildren()
                    local nearestCratePosition = Vector3.new(1167, 14, 225)
                    table.sort(nearestCrate, function(a, b)
                        return localPlayer:DistanceFromCharacter(a.Position) < localPlayer:DistanceFromCharacter(b.Position)
                    end)
                    nearestCrate = nearestCrate[1]
                    
                    -- looping through both workstations
                    for _, workstation in next, workstations do
                        -- ui
                        local uiPath = workstation.OrderDisplay.DisplayMain.BakerGUI

                        -- go to workstation
                        if uiPath.Used.Visible or not workstations[2].OrderDisplay.DisplayMain.BakerGUI.Used.Visible then
                            if bloxburger.jobs.realisticMode then
                                functions.teleportation.jobTeleport((workstation.CounterTop.CFrame - subtractVector3).Position)
                            else
                                humanoidRootPart.CFrame = middlePosition
                            end
                        end

                        -- refill ingredients
                        if workstation.Order.IngredientsLeft.Value == 0 then
                            -- get crate
                            while not modules.equipmentService:GetEquipped(localPlayer) do
                                if bloxburger.jobs.realisticMode then
                                    functions.teleportation.jobTeleport(nearestCratePosition)
                                else
                                    humanoidRootPart.CFrame = CFrame.new(nearestCratePosition)
                                end
                                network:FireServer({
                                    Type = "TakeIngredientCrate",
                                    Object = nearestCrate
                                })
                                task.wait(0.05)
                            end

                            -- refill crate
                            while modules.equipmentService:GetEquipped(localPlayer) do
                                if bloxburger.jobs.realisticMode then
                                    functions.teleportation.jobTeleport((workstation.CounterTop.CFrame - subtractVector3).Position)
                                else
                                    humanoidRootPart.CFrame = middlePosition
                                end
                                network:FireServer({
                                    Type = "RestockIngredients",
                                    Workstation = workstation
                                })
                                task.wait(0.05)
                            end
                        end

                        -- finish order
                        if workstation.Order.Value ~= "true" then
                            if bloxburger.jobs.realisticMode then
                                -- get row
                                local interactionRow = {
                                    ["Ham"] = 2,
                                    ["Pepperoni"] = 3,
                                    ["Vegetable"] = 4
                                }

                                task.wait(0.1 + randomOneDecimalNumber())
                                for _ = 1, workstation.Order.Value == "Cheese" and 3 or 4 do
                                    fireConnections(mainUi.InteractIndicator, "Activated")
                                    task.wait(0.1 + randomOneDecimalNumber() + (_ == 4 and 0.1 or 0))
                                end
                                if workstation.Order.Value ~= "Cheese" then
                                    for index, button in next, mainUi.InteractionMenu:WaitForChild("Center"):GetChildren() do
                                        if button.Name == "Button" and index == interactionRow[workstation.Order.Value] then
                                            fireConnections(button, "Activated")
                                            break
                                        end
                                    end
                                end

                                task.wait(0.1 + randomOneDecimalNumber())
                                fireConnections(uiPath:FindFirstChildWhichIsA("Frame").Done, "Activated")

                                task.wait(1)
                            else
                                network:FireServer({
                                    Type = "JobCompleted",
                                    Workstation = workstation,
                                    Order = {
                                        true,
                                        true,
                                        true,
                                        workstation.Order.Value
                                    }
                                })
                            end
                        end

                        -- only use one workstation if realistic
                        if bloxburger.jobs.realisticMode then
                            break
                        end
                    end
                end
            end
        end)

        -- stocker
        task.spawn(function()
            while task.wait() do
                if featureConfig.autoFarm.currentJob == "SupermarketStocker" and bloxburger.jobs.autoFarmEnabled and featureConfig.autoFarm.selectedJob == "SupermarketStocker" then
                    -- variables
                    local marketPath = workspace.Environment.Locations.Supermarket

                    -- get nearest crate
                    if bloxburger.jobs.realisticMode then
                        functions.teleportation.jobTeleport(functions.utilities.randomPosition(Vector3.new(819, 14, 115)), true)
                    end
                    local nearestCrate = marketPath.Crates:GetChildren()
                    table.sort(nearestCrate, function(a, b)
                        if a.Name == "Crate" then
                            return localPlayer:DistanceFromCharacter(a.Position) < localPlayer:DistanceFromCharacter(b.Position)
                        end
                    end)
                    nearestCrate = nearestCrate[1]

                    -- get nearest shelf
                    local shelfes = {}
                    local shelf
                    repeat
                        for _, shelf in next, marketPath.Shelves:GetChildren() do
                            if shelf:FindFirstChild("IsEmpty") and shelf.IsEmpty.Value then
                                table.insert(shelfes, shelf)
                            end
                        end
                        task.wait(0.05)
                    until #shelfes > 0
                    table.sort(shelfes, function(a, b)
                        local rootPartA, rootPartB
                        if a.Name:find("Fridge") then
                            rootPartA = a.Content_Full
                        else
                            rootPartA = a.PrimaryPart or a:FindFirstChildWhichIsA("Part")
                        end
                        if b.Name:find("Fridge") then
                            rootPartB = b.Content_Full
                        else
                            rootPartB = b.PrimaryPart or b:FindFirstChildWhichIsA("Part")
                        end

                        return localPlayer:DistanceFromCharacter(rootPartA.Position) < localPlayer:DistanceFromCharacter(rootPartB.Position)
                    end)
                    shelf = shelfes[1]

                    -- get crate
                    functions.teleportation.jobTeleport(nearestCrate.Position, true)
                    while not modules.equipmentService:GetEquipped(localPlayer) do
                        network:FireServer({
                            Type = "TakeFoodCrate",
                            Object = nearestCrate
                        })
                        task.wait(0.05)
                    end
                    
                    -- fill shelf
                    functions.teleportation.jobTeleport((shelf.Name:find("Fridge") and (shelf.Content_Full.Position - Vector3.new(0, 2.5, 2)) or (shelf.PrimaryPart or shelf:FindFirstChildWhichIsA("Part")).Position), true)
                    while modules.equipmentService:GetEquipped(localPlayer) do
                        network:FireServer({
                            Type = "RestockShelf",
                            Shelf = shelf
                        })
                        task.wait(0.05)
                    end

                    -- delay
                    if bloxburger.jobs.autoFarmEnabled then
                        if bloxburger.jobs.realisticMode then
                            task.wait(randomOneDecimalNumber())
                        else
                            task.wait(1)
                        end
                    end
                end
            end
        end)

        -- cashier
        task.spawn(function()
            while task.wait() do
                if featureConfig.autoFarm.currentJob == "SupermarketCashier" and bloxburger.jobs.autoFarmEnabled and featureConfig.autoFarm.selectedJob == "SupermarketCashier" then
                    -- functions
                    local function shouldUseNewBag(workstation)
                        local bags = workstation.Bags:GetChildren()

                        local activeBags = {}
                        for _, bag in next, bags do
                            if bag.Transparency == 0 then
                                table.insert(activeBags, bag)
                            end
                        end

                        if #activeBags == 0 then
                            return true
                        end
                        for _, bag in next, activeBags do
                            if #bag:GetChildren() < (3 + 1) then
                                return false
                            end
                        end
                        return true
                    end

                    -- variables
                    local marketPath = workspace.Environment.Locations.Supermarket
                    local currentCustomer
                    local currentWorkstation
                    local workstationPosition

                    -- get current customer, even if he is pointed to an other workstation
                    for _, customer in next, data.customers:GetChildren() do
                        if customer.Name == "SupermarketCustomer" and customer:FindFirstChild("HumanoidRootPart") and customer.HumanoidRootPart:FindFirstChild("Motor6D") and customer.HumanoidRootPart.Motor6D.Part1 then
                            local workstation = customer.HumanoidRootPart.Motor6D.Part1
                            if not isMemberOf(marketPath.CashierWorkstations, workstation) or customer:FindFirstChild("Bag") then
                                continue
                            end
                            workstation = workstation.Parent
                            
                            if workstation.InUse.Value == nil then
                                currentCustomer = customer
                                currentWorkstation = workstation
                                workstationPosition = (currentWorkstation.Scanner.CFrame * CFrame.new(-1, -1.5, 0))
                                break
                            end
                            if workstation.InUse.Value == localPlayer then
                                currentCustomer = customer
                                currentWorkstation = workstation
                                workstationPosition = (currentWorkstation.Scanner.CFrame * CFrame.new(-1, -1.5, 0))
                                break
                            end
                        end
                    end
                    if not currentCustomer or not currentWorkstation then
                        continue
                    end
                    currentCustomer:WaitForChild("Status")

                    -- going to workstation
                    local uiPath = currentWorkstation.Display.Screen.CashierGUI
                    if uiPath.Used.Visible then
                        functions.teleportation.jobTeleport(workstationPosition.Position, true)
                    end

                    -- scanning items
                    task.wait(randomOneDecimalNumber() + (bloxburger.jobs.realisticMode and 0.6 or 0))

                    local dropped = currentWorkstation.DroppedFood
                    while task.wait() do
                        -- checks
                        if not currentCustomer:FindFirstChild("Status") then
                            if currentCustomer:WaitForChild("HumanoidRootPart"):FindFirstChild("Motor6D") and isMemberOf(currentWorkstation, currentCustomer.HumanoidRootPart.Motor6D.Part1) then
                                currentCustomer:WaitForChild("Status")
                            else
                                break
                            end
                        end
                        if currentCustomer.Status.Value == "placed" and currentCustomer.Status.PlacedObjects.Value == currentCustomer.Status.ScannedObjects.Value then
                            break
                        end
                        if dropped:GetChildren() == 0 then
                            continue
                        end

                        -- restock bags
                        if currentWorkstation.BagsLeft.Value == 0 then
                            -- go to bags
                            functions.teleportation.jobTeleport(Vector3.new(836, 14, 110), true)

                            -- get nearest crate
                            local nearestCrate = {}
                            for _, crate in next, marketPath.Crates:GetChildren() do
                                if crate.Name == "BagCrate" then
                                    table.insert(nearestCrate, crate)
                                end
                            end
                            table.sort(nearestCrate, function(a, b)
                                return localPlayer:DistanceFromCharacter(a.Position) < localPlayer:DistanceFromCharacter(b.Position)
                            end)
                            nearestCrate = nearestCrate[1]

                            -- get bags
                            while not modules.equipmentService:GetEquipped(localPlayer) do
                                network:FireServer({
                                    Type = "TakeNewBags",
                                    Object = nearestCrate
                                })
                                task.wait(0.05)
                            end

                            -- go back and fill bags
                            functions.teleportation.jobTeleport(workstationPosition.Position, true)
                            while modules.equipmentService:GetEquipped(localPlayer) do
                                network:FireServer({
                                    Type = "RestockBags",
                                    Workstation = currentWorkstation
                                })
                                task.wait(0.05)
                            end
                        end

                        -- register drop
                        local drop = dropped:FindFirstChildWhichIsA("Part")
                        if not drop then
                            continue
                        end
                        local dropRemoved = dropped.ChildRemoved:Connect(function()
                            successScan = true
                        end)

                        -- take new bag
                        if shouldUseNewBag(currentWorkstation) then
                            network:FireServer({
                                Type = "TakeNewBag",
                                Workstation = currentWorkstation
                            })
                            task.wait(randomOneDecimalNumber() + (bloxburger.jobs.realisticMode and 0.175 or 0))
                        end

                        -- scan
                        repeat
                            network:FireServer({
                                Type = "ScanDroppedItem",
                                Item = drop
                            })
                            task.wait(0.1)
                        until successScan
                        dropRemoved:Disconnect()

                        task.wait(randomOneDecimalNumber() + (bloxburger.jobs.realisticMode and 0.2 or 0))
                    end

                    -- finishing cashiering
                    if bloxburger.jobs.realisticMode then
                        task.wait(1 + randomOneDecimalNumber())
                        fireConnections(uiPath:FindFirstChildWhichIsA("Frame").Done, "Activated")
                    else
                        network:FireServer({
                            Type = "JobCompleted",
                            Workstation = currentWorkstation
                        })
                    end

                    -- delay
                    task.wait(1)
                end
            end
        end)

        -- janitor
        task.spawn(function()
            while task.wait() do
                if featureConfig.autoFarm.currentJob == "CleanJanitor" and bloxburger.jobs.autoFarmEnabled and featureConfig.autoFarm.selectedJob == "CleanJanitor" then
                    -- variables
                    local cleanPath = workspace.Environment.Locations.GreenClean

                    -- get nearest spawn
                    local spawns = {}
                    for _, spawn in next, cleanPath.Spawns:GetChildren() do
                        if spawn:FindFirstChild("Object") then
                            table.insert(spawns, spawn)
                        end
                    end
                    table.sort(spawns, function(a, b)
                        return localPlayer:DistanceFromCharacter(a.Position) < localPlayer:DistanceFromCharacter(b.Position)
                    end)
                    local spawn = spawns[1]

                    -- go to spawn
                    functions.teleportation.jobTeleport((spawn.CFrame * CFrame.new(0, 0, 1)).Position, {
                        AgentCanJump = true
                    })

                    -- clean spot
                    local result
                    repeat
                        result = network:InvokeServer({
                            Type = "CleanJanitorObject",
                            Spawn = spawn
                        })
                        task.wait(0.1)
                    until result
                end
            end
        end)

        -- mechanic
        task.spawn(function()
            while task.wait() do
                if featureConfig.autoFarm.currentJob == "MikesMechanic" and bloxburger.jobs.autoFarmEnabled and featureConfig.autoFarm.selectedJob == "MikesMechanic" then
                    -- variables
                    local mikePath = workspace.Environment.Locations.MikesMotors
                    local currentCustomer
                    local currentWorkstation
                    local workstationPosition

                    -- get current customer, even if he is pointed to an other workstation
                    for _, customer in next, data.customers:GetChildren() do
                        if customer.Name == "MikesMotorsCustomer" and customer:FindFirstChild("HumanoidRootPart") and customer.HumanoidRootPart:FindFirstChild("VehicleWeld") and customer.HumanoidRootPart:FindFirstChild("AttachWeld") then
                            local workstation = customer.HumanoidRootPart.AttachWeld.Part1
                            if not isMemberOf(mikePath.MechanicWorkstations, workstation) then
                                continue
                            end
                            workstation = workstation.Parent
                            
                            if workstation.InUse.Value == nil then
                                currentCustomer = customer
                                currentWorkstation = workstation
                                workstationPosition = (currentWorkstation.CustomerTarget.CFrame * CFrame.new(-1, 0, -5.5))
                                break
                            end
                            if workstation.InUse.Value == localPlayer then
                                currentCustomer = customer
                                currentWorkstation = workstation
                                workstationPosition = (currentWorkstation.CustomerTarget.CFrame * CFrame.new(-1, 0, -5.5))
                                break
                            end
                        end
                    end
                    if not currentCustomer or not currentWorkstation then
                        continue
                    end

                    -- going to workstation
                    local uiPath = currentWorkstation.Display.Screen.MechanicGUI
                    if uiPath.Used.Visible then
                        functions.teleportation.jobTeleport(workstationPosition.Position, true)
                    end

                    -- getting order type
                    local order = currentCustomer.Order
                    local orders = {}
                    do
                        for _, order in next, order:GetChildren() do
                            table.insert(orders, order.Name)
                        end
                    end
                    local orderType = (table.find(orders, "Color") and "Color") or (table.find(orders, "Wheels") and "Wheels") or (table.find(orders, "Oil") and "Oil") or "undefined"
                    local orderValue = order:FindFirstChild(orderType).Value

                    -- fixing bike
                    if orderType == "Color" then
                        local painter = mikePath.PaintingEquipment:FindFirstChild(orderValue)

                        functions.teleportation.jobTeleport(painter.PrimaryPart.Position, true)
                        while not modules.equipmentService:GetEquipped(localPlayer) do
                            network:FireServer({
                                Type = "TakePainter",
                                Object = painter
                            })
                            task.wait(0.05)
                        end
                        functions.teleportation.jobTeleport(workstationPosition.Position, true)

                        network:FireServer({
                            Type = "FixBike",
                            Workstation = currentWorkstation
                        })

                        while modules.equipmentService:GetEquipped(localPlayer) do
                            task.wait()
                        end
                    elseif orderType == "Oil" then
                        local oilCan = mikePath.OilCans:FindFirstChild("Can")

                        functions.teleportation.jobTeleport(oilCan.PrimaryPart.Position, true)
                        while not modules.equipmentService:GetEquipped(localPlayer) do
                            network:FireServer({
                                Type = "TakeOil",
                                Object = oilCan
                            })
                            task.wait(0.05)
                        end
                        functions.teleportation.jobTeleport(workstationPosition.Position, true)

                        network:FireServer({
                            Type = "FixBike",
                            Workstation = currentWorkstation
                        })

                        while modules.equipmentService:GetEquipped(localPlayer) do
                            task.wait()
                        end
                    elseif orderType == "Wheels" then
                        local wheel = mikePath.TireRacks:FindFirstChild(orderValue)

                        for index = 1, 2 do
                            local front = index == 1 and true or false

                            functions.teleportation.jobTeleport(wheel.Origin.Position, true)
                            while not modules.equipmentService:GetEquipped(localPlayer) do
                                network:FireServer({
                                    Type = "TakeWheel",
                                    Object = wheel
                                })
                                task.wait(0.05)
                            end
                            functions.teleportation.jobTeleport(workstationPosition.Position, true)

                            network:FireServer({
                                Type = "FixBike",
                                Workstation = currentWorkstation,
                                Front = front
                            })

                            while modules.equipmentService:GetEquipped(localPlayer) do
                                task.wait()
                            end
                        end
                    end

                    -- finishing job
                    functions.teleportation.jobTeleport(workstationPosition.Position, true)
                    network:FireServer({
                        Type = "JobCompleted",
                        Workstation = currentWorkstation
                    })

                    -- delay
                    task.wait(3)
                end
            end
        end)

        -- wood cutter
        task.spawn(function()
            while task.wait() do
                if featureConfig.autoFarm.currentJob == "LumberWoodcutter" and bloxburger.jobs.autoFarmEnabled and featureConfig.autoFarm.selectedJob == "LumberWoodcutter" then
                    -- get nearest tree
                    local trees = {}
                    for _, tree in next, workspace.Environment.Trees:GetChildren() do
                        if tree:FindFirstChild("Body") and tree:FindFirstChild("Leaves") and localPlayer:DistanceFromCharacter(tree.Body.Position) < 50 and not tree:FindFirstChild("DoneVDX") then
                            table.insert(trees, tree)
                        end
                    end
                    table.sort(trees, function(a, b)
                        return localPlayer:DistanceFromCharacter(a.Body.Position) < localPlayer:DistanceFromCharacter(b.Body.Position)
                    end)
                    local tree = trees[1]
                    local oldPosition = tree.Body.Position

                    -- teleport to tree
                    functions.teleportation.jobTeleport((tree.Body.CFrame * CFrame.new(0, -1, 3)).Position, true)
                    local cframe = {(CFrame.lookAt(
                        humanoidRootPart.Position,
                        Vector3.new(tree.Body.Position.X, humanoidRootPart.Position.Y, tree.Body.Position.Z)
                    )):components()}
                    for _ = 1, 3 do
                        table.remove(cframe, 1)
                    end
                    local endCframe = CFrame.new(humanoidRootPart.CFrame.X, humanoidRootPart.CFrame.Y, humanoidRootPart.CFrame.Z, unpack(cframe))
                    humanoidRootPart.CFrame = endCframe

                    -- chop tree
                    repeat
                        task.spawn(function()
                            network:FireServer({
                                Type = "UseHatchet",
                                Tree = tree
                            })
                        end)
                        task.wait(0.1)
                    until not tree:FindFirstChild("Body") or tree.Body.Position ~= oldPosition

                    -- mark tree as chopped
                    Instance.new("BoolValue", tree).Name = "DoneVDX"
                end
            end
        end)
    end
end

-- automatic
do
    -- sections
    ui.pages.automatic.sections = {
        autoCook = ui.pages.automatic:Section("Auto Cook"),
        autoMood = ui.pages.automatic:Section("Auto Mood"),
        autoSkills = ui.pages.automatic:Section("Auto Skills")
    }

    -- auto cook
    do
        ui.pages.automatic.sections.autoCook:Dropdown("Select Receipt", featureConfig.autoCook.foodList, function(food)
            featureConfig.autoCook.selectedFood = food
        end)
        ui.pages.automatic.sections.autoCook:Toggle("Store Food In Fridge", true, function(storeInFridge)
            featureConfig.autoCook.storeInFridge = storeInFridge
        end)
        ui.pages.automatic.sections.autoCook:Slider("Cook Amount", {
            minValue = 1,
            maxValue = 25,
            currentValue = 1,
            decimals = 0
        }, function(amount)
            featureConfig.autoCook.cookAmount = amount
        end)
        ui.pages.automatic.sections.autoCook:Line()
        ui.pages.automatic.sections.autoCook.status = ui.pages.automatic.sections.autoCook:DoubleLabel("Status", "Idling", Color3.fromRGB(50, 75, 200))
        ui.pages.automatic.sections.autoCook:Button("Cook Selected Receipt", function()
            if not featureConfig.autoCook.selectedFood then
                return notification.sideNotify("Error, no food selected.")
            end
            if featureConfig.autoCook.isCooking then
                return notification.sideNotify("Error, you are already cooking.")
            end

            local savedAmounts = featureConfig.autoCook.cookAmount
            local oldCFrame = humanoidRootPart.CFrame

            for index = 1, savedAmounts do
                if not functions.automatic.autoCook(featureConfig.autoCook.selectedFood, {
                    label = ui.pages.automatic.sections.autoCook.status,
                    index = index,
                    max = savedAmounts
                }) then
                    break
                end
                if featureConfig.autoCook.abortCooking then
                    featureConfig.autoCook.abortCooking = false
                    notification.sideNotify("Success, auto cook has been aborted.")
                    break
                end
            end
            functions.teleportation.tween(oldCFrame.Position)
            ui.pages.automatic.sections.autoCook.status:Text("Idling")
        end)
        ui.pages.automatic.sections.autoCook:Button("Abort Cooking", function()
            if not featureConfig.autoCook.isCooking then
                return notification.sideNotify("Error, you are currently not cooking.")
            elseif featureConfig.autoCook.abortCooking then
                return notification.sideNotify("Error, please wait for the current food to be aborted.")
            end
            featureConfig.autoCook.abortCooking = true
            notification.sideNotify("Please wait for the current food to get finished, then it will stop.")
        end)
    end

    -- auto mood
    do
        ui.pages.automatic.sections.autoMood.selectedToBoost = ui.pages.automatic.sections.autoMood:DoubleLabel("Selected Moods", "None Selected", Color3.fromRGB(150, 150, 200))
        ui.pages.automatic.sections.autoMood:Dropdown("Select Moods", {
            "Fun", "Energy", "Hunger", "Hygiene"
        }, function(selected)
            local alreadyInList = table.find(featureConfig.autoMood.toBoost, selected)
            if alreadyInList then
                table.remove(featureConfig.autoMood.toBoost, alreadyInList)
            else
                table.insert(featureConfig.autoMood.toBoost, selected)
            end
            ui.pages.automatic.sections.autoMood.selectedToBoost:Text(table.concat(featureConfig.autoMood.toBoost, ", "))
        end)
        ui.pages.automatic.sections.autoMood:Slider("Boost Amount", {
            minValue = 1,
            maxValue = 100,
            currentValue = 100,
            decimals = 0
        }, function(amount)
            featureConfig.autoMood.amountToBoost = amount
        end)
        ui.pages.automatic.sections.autoMood:Line()
        ui.pages.automatic.sections.autoMood.statusLabel = ui.pages.automatic.sections.autoMood:DoubleLabel("Status", "Idling", Color3.fromRGB(50, 75, 200))
        ui.pages.automatic.sections.autoMood:Button("Boost Mood", function()
            if featureConfig.autoMood.isBoosting then
                return notification.sideNotify("Error, you are already boosting your mood.")
            end
            if #featureConfig.autoMood.toBoost == 0 then
                return notification.sideNotify("Error, no moods selected.")
            end

            local oldCFrame = humanoidRootPart.CFrame
            local toBoostAmount = featureConfig.autoMood.toBoost

            featureConfig.autoMood.isBoosting = true
            for index, mood in next, toBoostAmount do
                functions.automatic.boostMood(mood, {
                    label = ui.pages.automatic.sections.autoMood.statusLabel,
                    index = index,
                    max = #toBoostAmount
                })
                if featureConfig.autoMood.abortBoosting then
                    notification.sideNotify("Success, aborted auto mood.")
                    break
                end
            end

            ui.pages.automatic.sections.autoMood.statusLabel:Text("Idling")
            featureConfig.autoMood.abortBoosting = false
            featureConfig.autoMood.isBoosting = false

            task.wait(0.1)
            functions.teleportation.tween(oldCFrame.Position, true)
        end)
        ui.pages.automatic.sections.autoMood:Button("Abort Boosting Mood", function()
            if featureConfig.autoMood.abortBoosting then
                return notification.sideNotify("Error, you are already aborting auto mood.")
            end
            featureConfig.autoMood.abortBoosting = false
        end)
    end

    -- auto skills
    do
        ui.pages.automatic.sections.autoSkills.settings = {}
        ui.pages.automatic.sections.autoSkills.selectedToBoost = ui.pages.automatic.sections.autoSkills:DoubleLabel("Status", "Idling", Color3.fromRGB(50, 75, 200))
        featureConfig.autoSkills.updateLabel = ui.pages.automatic.sections.autoSkills.selectedToBoost

        local skillList = {}
        for _, skill in next, data.skills do
            table.insert(skillList, skill.name)
        end
        ui.pages.automatic.sections.autoSkills:Dropdown("Selected Skill", skillList, function(skill)
            featureConfig.autoSkills.selectedSkill = skill
        end)

        ui.pages.automatic.sections.autoSkills:Line()

        featureConfig.autoSkills.enabledToggle = ui.pages.automatic.sections.autoSkills:Toggle("Enable Skill Farm", false, function(enabled)
            featureConfig.autoSkills.enabled = enabled
        end)

        ui.pages.automatic.sections.autoSkills:Line()

        ui.pages.automatic.sections.autoSkills:Label("Settings")

        ui.pages.automatic.sections.autoSkills.settings.toCook = ui.pages.automatic.sections.autoSkills:Dropdown("Cooking: Select Receipt", featureConfig.autoCook.foodList, function(toCook)
            -- skill check
            if clientStats.SkillData.Cooking.Value < (data.foodList[toCook].CookSkill or 0) then
                featureConfig.autoSkills.settings.toCook = "Hot Dogs"
                task.spawn(function()
                    task.wait()
                    ui.pages.automatic.sections.autoSkills.settings.toCook:Selected("Hot Dogs")
                end)
                return notification.sideNotify(("You don't have the required skill level to farm:\nAuto Skills: Cooking\n-with %s\n\nIt will use the default food (Hot Dogs) instead.\n\nRequired: %s\nCurrent: %s"):format(toCook,(data.foodList[toCook].CookSkill or 0), clientStats.SkillData.Cooking.Value))
            end
    
            featureConfig.autoSkills.settings.toCook = toCook
        end)
        ui.pages.automatic.sections.autoSkills.settings.toCook:Selected("Hot Dogs")
        featureConfig.autoSkills.settings.toCook = "Hot Dogs"

        ui.pages.automatic.sections.autoSkills.settings.toPlant = ui.pages.automatic.sections.autoSkills:Dropdown("Gardening: To Plant Farm", featureConfig.autoSkills.plantList, function(toPlant)
            -- skill check
            if dataRequire(data.items.Garden)[toPlant].Locked and dataRequire(data.items.Garden)[toPlant].Locked.Skill_Gardening and dataRequire(data.items.Garden)[toPlant].Locked.Skill_Gardening > clientStats.SkillData.Gardening.Value then
                featureConfig.autoSkills.settings.toPlant = "Short Grass"
                task.spawn(function()
                    task.wait()
                    ui.pages.automatic.sections.autoSkills.settings.toPlant:Selected("Short Grass")
                end)
                return notification.sideNotify(("You don't have the required skill level to farm:\nAuto Skills: Gardening\n-with %s\n\nIt will use the default plant (Short Grass) instead.\n\nRequired: %s\nCurrent: %s"):format(toPlant, dataRequire(data.items.Garden)[toPlant].Locked.Skill_Gardening, clientStats.SkillData.Gardening.Value))
            end
    
            featureConfig.autoSkills.settings.toPlant = toPlant
        end)
        ui.pages.automatic.sections.autoSkills.settings.toPlant:Selected("Short Grass")
        featureConfig.autoSkills.settings.toPlant = "Short Grass"

        task.spawn(function()
            while task.wait() do
                -- skill farm
                if not featureConfig.autoSkills.enabled then
                    continue
                end
                local function quitFarming(textToNotify)
                    if textToNotify then
                        notification.sideNotify(textToNotify)
                    end
                    featureConfig.autoSkills.enabled = false
                    featureConfig.autoSkills.enabledToggle:Toggle(false)
                end

                -- checks
                if not featureConfig.autoSkills.selectedSkill then
                    quitFarming(("Select a %s"):format("Skill"))
                    continue
                end
                if not functions.utilities.attemptPayBills() then
                    quitFarming(("Pay your %s first."):format("Bills"))
                    continue
                end

                if featureConfig.autoSkills.selectedSkill == "Athletic" then
                    -- get objects
                    local supportedItems = {}
                    local ownedObjects = {}

                    for name, item in next, dataRequire(data.items.Training) do
                        if item.Types and not table.find(item.Types, "KickableBall") then
                            table.insert(supportedItems, {item = name, type = item.Types[1]})
                        end
                    end
                    for _, item in next, functions.utilities.getCurrentPlot().House.Objects:GetChildren() do
                        local itemData
                        for index, data in next, supportedItems do
                            if data.item == item.Name then
                                itemData = data
                            end
                        end
                        if itemData and (item:FindFirstChild("AttachPos") and not item.AttachPos:FindFirstChild("_attachOccupied")) then
                            table.insert(ownedObjects, {
                                item = item,
                                type = itemData.type
                            })
                        end
                    end
                    table.sort(ownedObjects, function(a, b)
                        return localPlayer:DistanceFromCharacter(a.item.Position) < localPlayer:DistanceFromCharacter(b.item.Position)
                    end)

                    -- get object
                    local object = ownedObjects[1]
                    if not object then
                        quitFarming("You must have a training item placed on your plot, like Punching Bag.")
                        continue
                    end

                    -- going to object
                    functions.teleportation.tween(object.item.Position)

                    -- interacting with object
                    local interactionCount = 2
                    while true do
                        network:FireServer({
                            Type = "Interact",
                            Target = object.item,
                            Path = tostring(interactionCount)
                        })
                        task.wait(0.15)
                        if object.item.AttachPos:FindFirstChild("_attachOccupied") then
                            break
                        end

                        interactionCount -= 1
                    end
                    
                    -- live status
                    repeat
                        local calculatedPercent = math.floor(math.floor(data.skills[featureConfig.autoSkills.selectedSkill].progress) * 100 / math.floor(modules.skillData:GetRequiredProgress(data.skills[featureConfig.autoSkills.selectedSkill].level)))
                        featureConfig.autoSkills.updateLabel:Text(("Leveling %s: %s%%"):format(featureConfig.autoSkills.selectedSkill, calculatedPercent))
                        task.wait()
                    until not featureConfig.autoSkills.enabled
                elseif featureConfig.autoSkills.selectedSkill == "Writing" then
                    -- get objects
                    local supportedItems = {}
                    local ownedObjects = {}

                    for name, item in next, dataRequire(data.items.Electronics) do
                        if item.Types and table.find(item.Types, "Computer") then
                            table.insert(supportedItems, {item = name, type = item.Types[1]})
                        end
                    end
                    for _, item in next, functions.utilities.getCurrentPlot().House:GetDescendants() do
                        if item.Parent.Name ~= "ItemHolder" and item.Parent.Parent.Name ~= "House" then
                            continue
                        end

                        local itemData
                        for index, data in next, supportedItems do
                            if data.item == item.Name then
                                itemData = data
                            end
                        end
                        if itemData then
                            table.insert(ownedObjects, {
                                item = item,
                                type = itemData.type
                            })
                        end
                    end
                    table.sort(ownedObjects, function(a, b)
                        return localPlayer:DistanceFromCharacter(a.item.Position) < localPlayer:DistanceFromCharacter(b.item.Position)
                    end)

                    -- get object
                    local object = ownedObjects[1]
                    if not object then
                        quitFarming("You must have a computer placed on your plot.")
                        continue
                    end

                    -- going to object
                    functions.teleportation.tween(object.item.Position)

                    -- interacting with object
                    network:FireServer({
                        Type = "Interact",
                        Target = object.item,
                        Path = "4"
                    })
                    
                    -- live status
                    repeat
                        local calculatedPercent = math.floor(data.skills[featureConfig.autoSkills.selectedSkill].progress * 100 / modules.skillData:GetRequiredProgress(data.skills[featureConfig.autoSkills.selectedSkill].level))
                        featureConfig.autoSkills.updateLabel:Text(("Leveling %s: %s%%"):format(featureConfig.autoSkills.selectedSkill, calculatedPercent))
                        task.wait()
                    until not featureConfig.autoSkills.enabled
                elseif featureConfig.autoSkills.selectedSkill == "Intelligence" then
                    -- get objects
                    local supportedItems = {}
                    local ownedObjects = {}

                    for name, item in next, dataRequire(data.items.Electronics) do
                        if item.Types and table.find(item.Types, "Computer") then
                            table.insert(supportedItems, {item = name, type = item.Types[1]})
                        end
                    end
                    for _, item in next, functions.utilities.getCurrentPlot().House:GetDescendants() do
                        if item.Parent.Name ~= "ItemHolder" and item.Parent.Parent.Name ~= "House" then
                            continue
                        end

                        local itemData
                        for index, data in next, supportedItems do
                            if data.item == item.Name then
                                itemData = data
                            end
                        end
                        if itemData then
                            table.insert(ownedObjects, {
                                item = item,
                                type = itemData.type
                            })
                        end
                    end
                    table.sort(ownedObjects, function(a, b)
                        return localPlayer:DistanceFromCharacter(a.item.Position) < localPlayer:DistanceFromCharacter(b.item.Position)
                    end)

                    -- get object
                    local object = ownedObjects[1]
                    if not object then
                        quitFarming("You must have a computer placed on your plot.")
                        continue
                    end

                    -- going to object
                    functions.teleportation.tween(object.item.Position)

                    -- interacting with object
                    network:FireServer({
                        Type = "Interact",
                        Target = object.item,
                        Path = "2"
                    })
                    
                    -- live status
                    repeat
                        local calculatedPercent = math.floor(data.skills[featureConfig.autoSkills.selectedSkill].progress * 100 / modules.skillData:GetRequiredProgress(data.skills[featureConfig.autoSkills.selectedSkill].level))
                        featureConfig.autoSkills.updateLabel:Text(("Leveling %s: %s%%"):format(featureConfig.autoSkills.selectedSkill, calculatedPercent))
                        task.wait()
                    until not featureConfig.autoSkills.enabled
                elseif featureConfig.autoSkills.selectedSkill == "Gardening" then
                    -- get objects
                    local supportedItems = {}
                    local ownedObjects = {}

                    for name, item in next, dataRequire(data.items.Garden) do
                        if item.CanPlant and item.CanPlaceFloor and not item.PlantData then
                            table.insert(supportedItems, {item = name, type = "Plant"})
                        end
                    end
                    for _, item in next, functions.utilities.getCurrentPlot().House:GetDescendants() do
                        if item.Parent.Name ~= "ItemHolder" and item.Parent.Parent.Name ~= "House" then
                            continue
                        end

                        local itemData
                        for index, data in next, supportedItems do
                            if data.item == item.Name then
                                itemData = data
                            end
                        end
                        if itemData then
                            table.insert(ownedObjects, {
                                item = item,
                                type = itemData.type
                            })
                        end
                    end
                    table.sort(ownedObjects, function(a, b)
                        return localPlayer:DistanceFromCharacter(a.item.Position) < localPlayer:DistanceFromCharacter(b.item.Position)
                    end)

                    -- get object
                    local object = ownedObjects[1]
                    if not object then
                        quitFarming("You must have something to plant placed on your plot, like a dirt pile.")
                        continue
                    end

                    -- going to object
                    functions.teleportation.tween(object.item.Position)

                    -- interacting with object
                    while task.wait() do
                        -- status update
                        local calculatedPercent = math.floor(data.skills[featureConfig.autoSkills.selectedSkill].progress * 100 / modules.skillData:GetRequiredProgress(data.skills[featureConfig.autoSkills.selectedSkill].level))
                        featureConfig.autoSkills.updateLabel:Text(("Leveling %s: %s%%"):format(featureConfig.autoSkills.selectedSkill, calculatedPercent))

                        -- plant
                        if not object.item:FindFirstChild("ItemHolder") or not object.item.ItemHolder:FindFirstChildWhichIsA("Part") then
                            network:InvokeServer({
                                Type = "PlantObject",
                                Target = object.item,
                                Name = featureConfig.autoSkills.settings.toPlant
                            })
    
                            task.wait()
                            repeat
                                task.wait()
                            until not character:FindFirstChild("PlantObject_Items") and not character:FindFirstChild("WaterPlant_Items") and not character:FindFirstChild("IKValues")
                            task.wait(0.15)
                        end

                        -- unplant
                        network:FireServer({
                            Type = "Interact",
                            Target = object.item.ItemHolder:FindFirstChildWhichIsA("Part"),
                            Path = "2"
                        })
                        task.wait(0.1)
                        if not character:FindFirstChild("PlantObject_Items") or not character:FindFirstChild("WaterPlant_Items") or not character:FindFirstChild("IKValues") then
                            network:FireServer({
                                Type = "Interact",
                                Target = object.item.ItemHolder:FindFirstChildWhichIsA("Part"),
                                Path = "1"
                            })
                        end

                        task.wait()
                        repeat
                            task.wait()
                        until not character:FindFirstChild("PlantObject_Items") and not character:FindFirstChild("WaterPlant_Items") and not character:FindFirstChild("IKValues")

                        -- loop ending
                        if not featureConfig.autoSkills.enabled then
                            break 
                        end
                    end
                elseif featureConfig.autoSkills.selectedSkill == "Cooking" then
                    while task.wait() do
                        -- status update
                        local calculatedPercent = math.floor(data.skills[featureConfig.autoSkills.selectedSkill].progress * 100 / modules.skillData:GetRequiredProgress(data.skills[featureConfig.autoSkills.selectedSkill].level))
                        featureConfig.autoSkills.updateLabel:Text(("Leveling %s: %s%%"):format(featureConfig.autoSkills.selectedSkill, calculatedPercent))
                        task.wait()
    
                        -- cooking
                        local result = functions.automatic.autoCook(featureConfig.autoSkills.settings.toCook)
                        if not result then
                            quitFarming()
                            break
                        end

                        -- loop ending
                        if not featureConfig.autoSkills.enabled then
                            quitFarming()
                            break
                        end
                    end
                elseif featureConfig.autoSkills.selectedSkill == "Crafting" or featureConfig.autoSkills.selectedSkill == "Programming" then
                    quitFarming("Not able to farm this skill yet.")
                    continue
                elseif featureConfig.autoSkills.selectedSkill == "Music" then
                    -- get objects
                    local supportedItems = {}
                    local ownedObjects = {}

                    for name, item in next, dataRequire(data.items.Instruments) do
                        if not item.CanEquip and not table.find(item.Types, "HeldInstrument") then
                            table.insert(supportedItems, {item = name, type = item.Types[1]})
                        end
                    end
                    for _, item in next, functions.utilities.getCurrentPlot().House:GetDescendants() do
                        if item.Parent.Name ~= "ItemHolder" and item.Parent.Parent.Name ~= "House" then
                            continue
                        end

                        local itemData
                        for index, data in next, supportedItems do
                            if data.item == item.Name then
                                itemData = data
                            end
                        end
                        if itemData then
                            table.insert(ownedObjects, {
                                item = item,
                                type = itemData.type
                            })
                        end
                    end
                    table.sort(ownedObjects, function(a, b)
                        return localPlayer:DistanceFromCharacter(a.item.Position) < localPlayer:DistanceFromCharacter(b.item.Position)
                    end)

                    -- get object
                    local object = ownedObjects[1]
                    if not object then
                        quitFarming("You must have an object placed on your plot, where you can play music on, like a piano.")
                        continue
                    end

                    -- going to object
                    functions.teleportation.tween(object.item.Position)

                    -- interacting with object
                    network:FireServer({
                        Type = "Interact",
                        Target = object.item,
                        Path = "1/1"
                    })
                    
                    -- live status
                    repeat
                        local calculatedPercent = math.floor(data.skills[featureConfig.autoSkills.selectedSkill].progress * 100 / modules.skillData:GetRequiredProgress(data.skills[featureConfig.autoSkills.selectedSkill].level))
                        featureConfig.autoSkills.updateLabel:Text(("Leveling %s: %s%%"):format(featureConfig.autoSkills.selectedSkill, calculatedPercent))
                        task.wait()
                    until not featureConfig.autoSkills.enabled
                elseif featureConfig.autoSkills.selectedSkill == "Painting" then
                    -- get objects
                    local ownedObjects = {}

                    for _, item in next, functions.utilities.getCurrentPlot().House:GetDescendants() do
                        if item.Parent.Name ~= "ItemHolder" and item.Parent.Parent.Name ~= "House" then
                            continue
                        end

                        if item.Name == "Painting Stand" then
                            table.insert(ownedObjects, {
                                item = item,
                                type = "Paint"
                            })
                        end
                    end
                    table.sort(ownedObjects, function(a, b)
                        return localPlayer:DistanceFromCharacter(a.item.Position) < localPlayer:DistanceFromCharacter(b.item.Position)
                    end)

                    -- get object
                    local object = ownedObjects[1]
                    if not object then
                        quitFarming("You must have a painting stand on your plot.")
                        continue
                    end

                    -- going to object
                    functions.teleportation.tween(object.item.Position)

                    -- interacting with object
                    network:FireServer({
                        Type = "Interact",
                        Target = object.item,
                        Path = "2"
                    })
                    
                    -- live status
                    repeat
                        local calculatedPercent = math.floor(data.skills[featureConfig.autoSkills.selectedSkill].progress * 100 / modules.skillData:GetRequiredProgress(data.skills[featureConfig.autoSkills.selectedSkill].level))
                        featureConfig.autoSkills.updateLabel:Text(("Leveling %s: %s%%"):format(featureConfig.autoSkills.selectedSkill, calculatedPercent))
                        task.wait()
                    until not featureConfig.autoSkills.enabled
                elseif featureConfig.autoSkills.selectedSkill == "Gaming" then
                    -- get objects
                    local supportedItems = {}
                    local ownedObjects = {}

                    for name, item in next, dataRequire(data.items.Electronics) do
                        if item.Types and table.find(item.Types, "Computer") then
                            table.insert(supportedItems, {item = name, type = item.Types[1]})
                        end
                    end
                    for _, item in next, functions.utilities.getCurrentPlot().House:GetDescendants() do
                        if item.Parent.Name ~= "ItemHolder" and item.Parent.Parent.Name ~= "House" then
                            continue
                        end

                        local itemData
                        for index, data in next, supportedItems do
                            if data.item == item.Name then
                                itemData = data
                            end
                        end
                        if itemData then
                            table.insert(ownedObjects, {
                                item = item,
                                type = itemData.type
                            })
                        end
                    end
                    table.sort(ownedObjects, function(a, b)
                        return localPlayer:DistanceFromCharacter(a.item.Position) < localPlayer:DistanceFromCharacter(b.item.Position)
                    end)

                    -- get object
                    local object = ownedObjects[1]
                    if not object then
                        quitFarming("You must have a computer placed on your plot.")
                        continue
                    end

                    -- going to object
                    functions.teleportation.tween(object.item.Position)

                    -- interacting with object
                    network:FireServer({
                        Type = "Interact",
                        Target = object.item,
                        Path = "1/" .. tostring(math.random(1, 5))
                    })
                    
                    -- live status
                    repeat
                        local calculatedPercent = math.floor(data.skills[featureConfig.autoSkills.selectedSkill].progress * 100 / modules.skillData:GetRequiredProgress(data.skills[featureConfig.autoSkills.selectedSkill].level))
                        featureConfig.autoSkills.updateLabel:Text(("Leveling %s: %s%%"):format(featureConfig.autoSkills.selectedSkill, calculatedPercent))
                        task.wait()
                    until not featureConfig.autoSkills.enabled
                end

                if not table.find({"Cooking", "Gardening"}, featureConfig.autoSkills.selectedSkill) then
                    network:FireServer({
                        Type = "Detach"
                    })
                end
                featureConfig.autoSkills.updateLabel:Text("Idling")
            end
        end)
    end
end

-- teleportation
do
    -- sections
    ui.pages.teleportation.sections = {
        teleportation = ui.pages.teleportation:Section("Teleportation")
    }

    -- elements
    featureConfig.teleportation.playerTargetTextbox = nil
    featureConfig.teleportation.playerTargetTextbox = ui.pages.teleportation.sections.teleportation:Textbox("Target", "Player Name", function(t)
        local targetPlayer = libraries.utilities:GetPlayer(t)
        if targetPlayer then
            featureConfig.teleportation.playerTargetTextbox:Selected(functions.utilities.getTextboxName(targetPlayer))
            featureConfig.teleportation.playerTarget = targetPlayer
        else
            featureConfig.teleportation.playerTargetTextbox:Selected(functions.utilities.getTextboxName(localPlayer))
            featureConfig.teleportation.playerTarget = localPlayer
        end
    end)
    featureConfig.teleportation.playerTargetTextbox:Selected(functions.utilities.getTextboxName(localPlayer))

    ui.pages.teleportation.sections.teleportation:Line()
    
    ui.pages.teleportation.sections.teleportation:Button("To Plot", function()
        for _ = 1, 2 do
            task.spawn(function()
                network:InvokeServer({
                    Type = "ToPlot",
                    Player = featureConfig.teleportation.playerTarget,
                })
            end)
        end
    end)
    ui.pages.teleportation.sections.teleportation:Button("Teleport To Player", function()
        functions.teleportation.underground(featureConfig.teleportation.playerTarget.Character.HumanoidRootPart)
    end)

    ui.pages.teleportation.sections.teleportation:Line()

    local locationList = {}
    for location, position in next, featureConfig.teleportation.locations do
        table.insert(locationList, location)
    end
    ui.pages.teleportation.sections.teleportation:Dropdown("Select Location", locationList, function(location)
        functions.teleportation.underground(featureConfig.teleportation.locations[location])
    end)

    ui.pages.teleportation.sections.teleportation:Line()

    ui.pages.teleportation.sections.teleportation:Toggle("Click To Teleport To Mouse Location", false, function(state)
        featureConfig.teleportation.clickTeleport = state
    end)

    -- mouse event
    userInputService.InputBegan:Connect(function(inputType)
        if inputType.UserInputType == Enum.UserInputType.MouseButton1 and featureConfig.teleportation.clickTeleport then
            functions.teleportation.underground(mouse.Hit.Position)
        end
    end)
end

-- vehicle
do
    -- sections
    ui.pages.vehicle.sections = {
        mods = ui.pages.vehicle:Section("Modification"),
        fly = ui.pages.vehicle:Section("Flying")
    }

    -- elements
    ui.pages.vehicle.sections.mods:DoubleLabel("Note", "Re-enter Vehicle to apply changes.", Color3.fromRGB(170, 170, 170))
    ui.pages.vehicle.sections.mods:Line()

    ui.pages.vehicle.sections.mods.stateLabel = ui.pages.vehicle.sections.mods:DoubleLabel("State", "No vehicle found.", Color3.fromRGB(175, 100, 100))
    ui.pages.vehicle.sections.mods:Line()

    for modification, data in next, featureConfig.vehicle.modificationList do
        ui.pages.vehicle.sections.mods:Slider(modification, data, function(value)
            featureConfig.vehicle.modificationList[modification].currentValue = value
        end)
    end

    ui.pages.vehicle.sections.mods:Line()

    ui.pages.vehicle.sections.mods:Toggle("Enable Modifications", false, function(state)
        featureConfig.vehicle.modificationEnabled = state
    end)

    ui.pages.vehicle.sections.fly.flyToggle = ui.pages.vehicle.sections.fly:Toggle("Vehicle Fly", false, function(state)
        if not functions.utilities.getVehicle() and state then
            return false, ui.pages.vehicle.sections.fly.flyToggle:Toggle(false), notification.sideNotify("Error, you need to be in a vehicle.")
        end
        libraries.flying.enabled = state
    end)

    character.ChildAdded:Connect(function(child)
        if child.Name:find("Vehicle_") then
            local cleanseName = child.Name:gsub("Vehicle_", "")
            ui.pages.vehicle.sections.mods.stateLabel:Text("Inside of " .. cleanseName .. ".")
            ui.pages.vehicle.sections.mods.stateLabel:Color(Color3.fromRGB(100, 200, 150))

            if featureConfig.vehicle.modificationEnabled then
                featureConfig.vehicle.clonedModifications = table.clone(data.vehicleData[cleanseName])

                data.vehicleData[cleanseName]["ForwardSpeed"] = featureConfig.vehicle.modificationList["Speed"].currentValue
                data.vehicleData[cleanseName]["ReverseSpeed"] = featureConfig.vehicle.modificationList["Speed"].currentValue
                data.vehicleData[cleanseName]["SpringLength"] = featureConfig.vehicle.modificationList["Spring"].currentValue
                data.vehicleData[cleanseName]["TurnSpeed"] = featureConfig.vehicle.modificationList["Turning"].currentValue
            end
            libraries.flying.speed = (featureConfig.vehicle.clonedModifications or data.vehicleData[cleanseName])["ForwardSpeed"] / 10
        end
    end)
    character.ChildRemoved:Connect(function(child)
        if child.Name:find("Vehicle_") then
            ui.pages.vehicle.sections.mods.stateLabel:Text("No vehicle found.")
            ui.pages.vehicle.sections.mods.stateLabel:Color(Color3.fromRGB(175, 100, 100))

            if featureConfig.vehicle.clonedModifications then
                local cleanseName = child.Name:gsub("Vehicle_", "")
                data.vehicleData[cleanseName] = featureConfig.vehicle.clonedModifications
                featureConfig.vehicle.clonedModifications = nil
            end
            if libraries.flying.enabled then
                ui.pages.vehicle.sections.fly.flyToggle:Toggle(false)
                libraries.flying.enabled = false
            end
        end
    end)
end

-- stats
do
    -- sections
    ui.pages.stats.sections = {
        input = ui.pages.stats:Section("Target"),
        stats = ui.pages.stats:Section("Stats"),
        mood = ui.pages.stats:Section("Mood"),
        skill = ui.pages.stats:Section("Skill"),
        house = ui.pages.stats:Section("House"),
        neighborhood = ui.pages.stats:Section("Neighborhood")
    }

    -- elements
    ui.pages.stats.sections.input.targetName = ui.pages.stats.sections.input:Textbox("Target", "Player Name", function(t)
        local targetPlayer = libraries.utilities:GetPlayer(t)
        if targetPlayer then
            ui.pages.stats.sections.input.targetName:Selected(functions.utilities.getTextboxName(targetPlayer))
            featureConfig.stats.selectedPlayer = targetPlayer
        else
            ui.pages.stats.sections.input.targetName:Selected(functions.utilities.getTextboxName(localPlayer))
            featureConfig.stats.selectedPlayer = localPlayer
        end
    end)
    ui.pages.stats.sections.input.targetName:Selected(functions.utilities.getTextboxName(localPlayer))

    ui.pages.stats.sections.stats.money = ui.pages.stats.sections.stats:DoubleLabel("Money", "$ 0", Color3.fromRGB(0, 170, 0))
    ui.pages.stats.sections.stats.blockbux = ui.pages.stats.sections.stats:DoubleLabel("Blockbux", "B$ 0", Color3.fromRGB(170, 0, 255))

    ui.pages.stats.sections.mood.fun = ui.pages.stats.sections.mood:DoubleLabel("Fun", "0%", Color3.fromRGB(200, 200, 200))
    ui.pages.stats.sections.mood.energy = ui.pages.stats.sections.mood:DoubleLabel("Energy", "0%", Color3.fromRGB(200, 200, 200))
    ui.pages.stats.sections.mood.hunger = ui.pages.stats.sections.mood:DoubleLabel("Hunger", "0%", Color3.fromRGB(200, 200, 200))
    ui.pages.stats.sections.mood.hygiene = ui.pages.stats.sections.mood:DoubleLabel("Hygiene", "0%", Color3.fromRGB(200, 200, 200))

    local skillList = {}
    for _, skill in next, data.skills do
        table.insert(skillList, skill.name)
    end
    ui.pages.stats.sections.skill:Dropdown("Selected Skill", skillList, function(skill)
        featureConfig.stats.selectedSkill = skill
    end)
    ui.pages.stats.sections.skill.skillLevel = ui.pages.stats.sections.skill:DoubleLabel("Skill Level", "Undefined", Color3.fromRGB(200, 200, 200))

    ui.pages.stats.sections.house.houseName = ui.pages.stats.sections.house:DoubleLabel("House Name", "Not found.", Color3.fromRGB(200, 200, 200))
    ui.pages.stats.sections.house:Line()
    ui.pages.stats.sections.house.houseValue = ui.pages.stats.sections.house:DoubleLabel("House Value", "$ 0", Color3.fromRGB(0, 170, 0))
    ui.pages.stats.sections.house.houseBlockbux = ui.pages.stats.sections.house:DoubleLabel("House Blockbux", "B$ 0", Color3.fromRGB(170, 0, 255))

    ui.pages.stats.sections.neighborhood.code = ui.pages.stats.sections.neighborhood:DoubleLabel("Code", "false", Color3.fromRGB(200, 0, 0))
    ui.pages.stats.sections.neighborhood.expiration = ui.pages.stats.sections.neighborhood:DoubleLabel("Expiration", "Expired", Color3.fromRGB(200, 200, 200))

    -- stat updater
    local updateEvent = Instance.new("BindableEvent")
    updateEvent.Event:Connect(function(arguments)
        local player = featureConfig.stats.selectedPlayer
        local statPath = replicatedStorage.Stats[player.Name]
        
        ui.pages.stats.sections.stats.money:Text(("$ %s"):format(beautifyMoney(statPath.Money.Value)))
        ui.pages.stats.sections.stats.blockbux:Text(("B$ %s"):format(beautifyMoney(statPath.Blockbux.Value)))

        ui.pages.stats.sections.mood.fun:Text(("%s%%"):format(math.floor(statPath.MoodData.Fun.Value)))
        ui.pages.stats.sections.mood.energy:Text(("%s%%"):format(math.floor(statPath.MoodData.Energy.Value)))
        ui.pages.stats.sections.mood.hunger:Text(("%s%%"):format(math.floor(statPath.MoodData.Hunger.Value)))
        ui.pages.stats.sections.mood.hygiene:Text(("%s%%"):format(math.floor(statPath.MoodData.Hygiene.Value)))

        ui.pages.stats.sections.skill.skillLevel:Text(featureConfig.stats.selectedSkill and tostring(statPath.SkillData[featureConfig.stats.selectedSkill].Value) or "Undefined")

        local currentHouse
        do
            local houses = {}
            local init = os.time()

            for _, house in next, statPath.Houses:GetChildren() do
                table.insert(houses, {
                    house = house,
                    used = house.LastUsed.Value
                })
            end
            table.sort(houses, function(a, b)
                return (init - a.used) < (init - a.used)
            end)

            currentHouse = houses[1].house
        end

        ui.pages.stats.sections.house.houseName:Text(currentHouse and currentHouse.Name or "Not found.")
        if currentHouse then
            ui.pages.stats.sections.house.houseValue:Text(("$ %s"):format(beautifyMoney(currentHouse.TotalValue.Value)))
            ui.pages.stats.sections.house.houseBlockbux:Text(("B$ %s"):format(beautifyMoney(currentHouse.BSValue.Value)))
        end

        local privateServer = ((statPath.PrivateServer.RenewTime.Value - os.time()) > 1000) and statPath.PrivateServer or false

        ui.pages.stats.sections.neighborhood.code:Text(privateServer and player.Name or "false")
        ui.pages.stats.sections.neighborhood.code:Color(privateServer and Color3.fromRGB(0, 200, 0) or Color3.fromRGB(200, 0, 0))

        if privateServer then
            ui.pages.stats.sections.neighborhood.expiration:Text(os.date("%B %A %dth, %Y %I%p", epochTime))
        else
            ui.pages.stats.sections.neighborhood.expiration:Text("Expired")
        end
    end)
    
    task.spawn(function()
        while true do
            if not pcall(function()
                updateEvent:Fire()
            end) then
                featureConfig.stats.selectedPlayer = localPlayer
                ui.pages.stats.sections.input.targetName:Selected(functions.utilities.getTextboxName(localPlayer))
            end
            
            task.wait()
        end
    end)
end

-- miscellaneous
do
    -- sections
    ui.pages.miscellaneous.sections = {
        character = ui.pages.miscellaneous:Section("Character"),
        house = ui.pages.miscellaneous:Section("House"),
        environment = ui.pages.miscellaneous:Section("Environment")
    }

    -- elements
    ui.pages.miscellaneous.sections.character:Dropdown("Select Age", {"Baby", "Toddler", "Kid", "Teen", "Adult"}, function(age)
        featureConfig.miscellaneous.character.age = age
    end):Selected("Adult")
    ui.pages.miscellaneous.sections.character:Button("Switch To Age", function()
        network:InvokeServer({
            Type = "SetAge",
            Value = featureConfig.miscellaneous.character.age
        })
    end)

    ui.pages.miscellaneous.sections.character:Line()

    ui.pages.miscellaneous.sections.character.outfitTarget = ui.pages.miscellaneous.sections.character:Textbox("Outfit Target", "Player Name", function(t)
        local targetPlayer = libraries.utilities:GetPlayer(t)
        if targetPlayer then
            ui.pages.miscellaneous.sections.character.outfitTarget:Selected(functions.utilities.getTextboxName(targetPlayer))
            featureConfig.miscellaneous.character.outfitTarget = targetPlayer
        else
            ui.pages.miscellaneous.sections.character.outfitTarget:Selected(functions.utilities.getTextboxName(localPlayer))
            featureConfig.miscellaneous.character.outfitTarget = localPlayer
        end
    end)
    ui.pages.miscellaneous.sections.character.outfitTarget:Selected(functions.utilities.getTextboxName(localPlayer))
    ui.pages.miscellaneous.sections.character.outfitIndex = ui.pages.miscellaneous.sections.character:Textbox("Outfit Index", "Outfit Index To Steal", function(index)
        local index = tonumber(index)
        if not index then
            return notification.notify("Index must be a number."), task.spawn(function()
                task.wait()
                ui.pages.miscellaneous.sections.character.outfitIndex:Selected("1")
                featureConfig.miscellaneous.character.outfitIndex = 1
            end)
        end

        featureConfig.miscellaneous.character.outfitIndex = index
    end)
    ui.pages.miscellaneous.sections.character.outfitIndex:Selected("1")

    ui.pages.miscellaneous.sections.character:Button("Steal Outfit [KICK CHANCE]", function()
        local localStatPath = clientStats
        local currentOutfitPath = localStatPath.Appearance.Outfits:FindFirstChildWhichIsA("IntValue")

        local targetStatPath = replicatedStorage.Stats[featureConfig.miscellaneous.character.outfitTarget.Name]
        local targetOutfitPath = targetStatPath.Appearance.Outfits:GetChildren()[featureConfig.miscellaneous.character.outfitIndex]

        if not targetOutfitPath then
            return notification.sideNotify("This outfit index could not be found.")
        end

        -- setting skil color
        network:InvokeServer({
            Type = "SetSkintone",
            Color = targetOutfitPath.Parent.Parent.SkinColor.Value
        })

        local layeredClothing, accessories = functions.utilities.getValueArrayFromInstance(targetOutfitPath.LayeredClothing), functions.utilities.getValueArrayFromInstance(targetOutfitPath.Accessories)
        for _ = 1, #layeredClothing / 2 do
            table.remove(layeredClothing, 1)
        end
        for _ = 1, #accessories / 2 do
            table.remove(accessories, 1)
        end

        -- entering edit state
        network:FireServer({
            Type = "EnterCharacterCustomizer",
            State = true
        })

        -- setting outfit
        network:InvokeServer({
            Type = "BuyOutfit",
            Outfit = currentOutfitPath,
            Assets = {
                ClassicShirt = targetOutfitPath.ClassicShirt.Value >= 0 and targetOutfitPath.ClassicShirt.Value or 0,
                ClassicPants = targetOutfitPath.ClassicPants.Value >= 0 and targetOutfitPath.ClassicPants.Value or 0,
                Emotes = {},
                LayeredClothing = layeredClothing,
                Accessories = accessories,
                Face = targetOutfitPath.Face.Value,
                Body = targetOutfitPath.Body.Value
            },
            Owned = {
                [1] = accessories[1] or layeredClothing[1]
            }
        })
        network:InvokeServer({
            Type = "BuyOutfit",
            Outfit = currentOutfitPath,
            Assets = {
                ClassicShirt = targetOutfitPath.ClassicShirt.Value >= 0 and targetOutfitPath.ClassicShirt.Value or 0,
                ClassicPants = targetOutfitPath.ClassicPants.Value >= 0 and targetOutfitPath.ClassicPants.Value or 0,
                Emotes = {},
                LayeredClothing = functions.utilities.getValueArrayFromInstance(targetOutfitPath.LayeredClothing),
                Accessories = functions.utilities.getValueArrayFromInstance(targetOutfitPath.Accessories),
                Face = targetOutfitPath.Face.Value,
                Body = targetOutfitPath.Body.Value
            },
            Owned = {
                [1] = functions.utilities.getValueArrayFromInstance(targetOutfitPath.Accessories)[1]
            }
        })

        -- leaving edit state
        network:FireServer({
            Type = "EnterCharacterCustomizer",
            State = false
        })
    end)

    ui.pages.miscellaneous.sections.character:Line()

    ui.pages.miscellaneous.sections.character:Button("Remove Stink Effect", function()
        if humanoidRootPart:FindFirstChildWhichIsA("ParticleEmitter") then
            for _, particles in next, humanoidRootPart:GetChildren() do
                if particles:IsA("ParticleEmitter") then
                    particles:Destroy()
                end
            end
            notification.sideNotify("Removed stink effects.")
        else
            notification.sideNotify("No stink effects found.")
        end
    end)

    ui.pages.miscellaneous.sections.character:Line()

    ui.pages.miscellaneous.sections.character:Slider("Jump Height", {
        maxValue = 500,
        minValue = 25,
        currentValue = 50,
        decimals = 0
    }, function(jumpPower)
        humanoid:FindFirstChild("SetJumpPower").Value = jumpPower
        humanoid.JumpPower = jumpPower
    end)
    ui.pages.miscellaneous.sections.character:Toggle("Noclip", false, function(state)
        featureConfig.miscellaneous.noclip = state
        if state then
            local whitelistedParts = {}
            for _, part in pairs(character:GetDescendants()) do
                if part:IsA("BasePart") and part.CanCollide then
                    table.insert(whitelistedParts, part)
                end
            end
    
            local noclipConnection = runService.RenderStepped:Connect(function()
                for _, part in next, whitelistedParts do
                    part.CanCollide = false
                end
            end)
    
            repeat
                task.wait()
            until not featureConfig.miscellaneous.noclip

            noclipConnection:Disconnect()
            for _, part in next, whitelistedParts do
                part.CanCollide = true
            end
        end
    end)
    ui.pages.miscellaneous.sections.character:Toggle("Infinite Stamina", false, function(state)
        if state == false then
            modules.staminaService.GetMaxStaminaValue = data.oldStaminaFunction
        elseif state == true then
            modules.staminaService.GetMaxStaminaValue = function()
                return 9e9
            end
        end
    end)
    ui.pages.miscellaneous.sections.character:Line()
    ui.pages.miscellaneous.sections.character:Button("Give Client Game Passes", function()
        for _, gamepass in next, clientStats.Gamepasses:GetChildren() do
            v.Value = true
        end
    end)

    ui.pages.miscellaneous.sections.house:Button("Toggle All Light Switches", function()
        if featureConfig.autoFarm.currentJob then
            return notification.sideNotify("Error, you must be at your Plot, with no active job.")
        end
        
        -- variables
        local plot = functions.utilities.getCurrentPlot()
        local oldPosition = humanoidRootPart.CFrame
        local lightSwitches = {}

        -- fetching all light switches
        for _, wall in next, plot.House.Walls:GetChildren() do
            if wall:FindFirstChild("ItemHolder") then
                for _, lightSwitch in next, wall.ItemHolder:GetChildren() do
                    if string.find(lightSwitch.Name, "Light") and string.find(lightSwitch.Name, "Switch") then
                        table.insert(lightSwitches, lightSwitch)
                    end
                end
            end
        end

        -- looping through them
        local lightSwitchCount = #lightSwitches
        if #lightSwitches > 0 then
            for _ = 1, #lightSwitches do
                -- get nearest light switch
                local nearestSwitch
                local distance = 9e9
                for _, lightSwitch in next, lightSwitches do
                    local distanceToSwitch = localPlayer:DistanceFromCharacter(lightSwitch.Position)
                    if distanceToSwitch < distance then
                        distance = distanceToSwitch
                        nearestSwitch = lightSwitch
                    end
                end

                -- going there and toggling it
                functions.teleportation.tween(nearestSwitch.Position)
                network:FireServer({
                    Type = "Interact",
                    Target = nearestSwitch,
                    Path = "1"
                })
                
                table.remove(lightSwitches, table.find(lightSwitches, nearestSwitch))
            end
        else
            return notification.sideNotify("Error, No light switches have been located on your plot.")
        end

        notification.sideNotify(("Success, toggled %s light switches."):format(lightSwitchCount))
    end)
    ui.pages.miscellaneous.sections.house:Button("Toggle All Doors", function()
        if featureConfig.autoFarm.currentJob then
            return notification.sideNotify("Error, you must be at your Plot, with no active job.")
        end

        local answer
        modules.sideNotify:CreateNotification("Bloxburger", 13681831497, "Do you want to close or open all doors?", {
            {
                Text = "Close",
                Color = Color3.fromRGB(230, 0, 0),
                Clicked = function()
                    answer = "Close"
                end
            },
            {
                Text = "Open",
                Color = Color3.fromRGB(0, 230, 0),
                Clicked = function()
                    answer = "Open"
                end
            }
        })
        repeat
            task.wait()
        until answer
        
        -- variables
        local plot = functions.utilities.getCurrentPlot()
        local oldPosition = humanoidRootPart.CFrame
        local doors = {}

        -- fetching all doors
        for _, wall in next, plot.House.Walls:GetChildren() do
            if wall:FindFirstChild("ItemHolder") then
                for _, door in next, wall.ItemHolder:GetChildren() do
                    if string.find(door.Name, "Door") then
                        local isOpened = door:FindFirstChild("IsOpen", 1)
                        if not isOpened then
                            continue
                        end
                        isOpened = isOpened.Value

                        if (isOpened and answer == "Open") or (not isOpened and answer == "Close") then
                            continue
                        end

                        table.insert(doors, door)
                    end
                end
            end
        end

        -- looping through them
        local doorCount = #doors
        if #doors > 0 then
            for _ = 1, #doors do
                -- get nearest door
                local nearestDoor
                local distance = 9e9
                for _, door in next, doors do
                    local distanceToSwitch = localPlayer:DistanceFromCharacter(door.Position)
                    if distanceToSwitch < distance then
                        distance = distanceToSwitch
                        nearestDoor = door
                    end
                end

                -- going there and toggling it
                functions.teleportation.tween(nearestDoor.Position)
                network:FireServer({
                    Type = "Interact",
                    Target = nearestDoor,
                    Path = "1"
                })
                
                table.remove(doors, table.find(doors, nearestDoor))
            end
        else
            return notification.sideNotify("Error, No doors have been located on your plot.")
        end

        notification.sideNotify(("Success, %s %s doors."):format((answer == "Close" and "closed" or (answer == "Open" and "opened")), doorCount))
    end)

    ui.pages.miscellaneous.sections.environment:Toggle("Enable Time Overwrite", false, function(state)
        featureConfig.miscellaneous.environment.enabled = state
    end)
    ui.pages.miscellaneous.sections.environment:Dropdown("Time", {"Day", "Night", "Afternoon"}, function(time)
        featureConfig.miscellaneous.environment.time = ((time == "Day") and 500) or ((time == "Night") and 1500) or ((time == "Afternoon") and 1050)
    end):Selected("Day")
    ui.pages.miscellaneous.sections.environment:Dropdown("Weather", {"Clean", "Rain", "Fog", "Snow"}, function(weather)
        featureConfig.miscellaneous.environment.weather = weather
    end):Selected("Clean")
    ui.pages.miscellaneous.sections.environment:Slider("Wind Speed", {
        minValue = 1,
        maxValue = 500,
        currentValue = 1,
        decimals = 1
    }, function(windSpeed)
        featureConfig.miscellaneous.environment.windSpeed = windSpeed
    end)
end

-- fun
do
    -- sections
    ui.pages.fun.sections = {
        notification = ui.pages.fun:Section("Notification"),
        payCheck = ui.pages.fun:Section("Fake Pay Check")
    }

    -- elements
    ui.pages.fun.sections.notification:Dropdown("Notification Type", {"Message", "Confirmation", "Alert"}, function(type)
        featureConfig.fun.notification.type = type
    end):Selected("Message")
    ui.pages.fun.sections.notification:Textbox("Notification Type", "Text here", function(text)
        featureConfig.fun.notification.text = text
    end):Selected("This is a text.")
    ui.pages.fun.sections.notification:Button("Send Notification", function()
        if featureConfig.fun.notification.type == "Confirmation" then
            modules.notification:ConfirmBox(featureConfig.fun.notification.text, "Confirmation")
        elseif featureConfig.fun.notification.type == "Alert" then
            modules.notification:AlertBox(featureConfig.fun.notification.text, "Alert")
        elseif featureConfig.fun.notification.type == "Message" then
            modules.notification:MessageBox(featureConfig.fun.notification.text, "Notification")
        end
    end)

    ui.pages.fun.sections.payCheck:Slider("Amount", {
        minValue = 1000,
        maxValue = 1000000000,
        currentValue = 100000,
        decimals = 0
    }, function(amount)
        featureConfig.fun.payCheck.amount = amount
    end)
    ui.pages.fun.sections.payCheck:Button("Send Pay Check", function()
        modules.jobManager:ShowPaycheck(featureConfig.fun.payCheck.amount, "Bloxburger")
    end)
end

-- neighborhood
do
    -- sections
    ui.pages.neighborhood.sections = {
        codeStealing = ui.pages.neighborhood:Section("Private Server Stealer")
    }

    -- elements
    ui.pages.neighborhood.sections.codeStealing:Button("Check for Codes", function()
        -- variables
        local codes = {}

        -- check for codes
        for _, player in next, clientStats.Parent:GetChildren() do
            local privateServer = player:FindFirstChild("PrivateServer") or player:WaitForChild("PrivateServer")

            if player ~= clientStats and privateServer.RenewTime.Value > os.time() and privateServer.JoinPermission.Value == 0 then
                table.insert(codes, {
                    name = player.Name,
                    renew_time = privateServer.RenewTime.Value
                })
            end
        end

        -- check
        if #codes == 0 then
            return notification.sideNotify("No codes were found.")
        end

        -- add to cloud
        if featureConfig.neighborhood.uploadToCloud then
            task.spawn(function()
                for _, code in next, codes do
                    httpRequest({
                        Url = ("%s/code-system/uploadCode.php"):format(host),
                        Method = "POST",
                        Headers = {
                            ["Content-Type"] = "application/json"
                        },
                        Body = jsonEncode(code)
                    })
                end
            end)
        end

        -- handle the output
        local answer
        modules.sideNotify:CreateNotification("Bloxburger", 13681831497, ("Where do you want to output the %s?"):format((#codes == 1 and "code" or "codes")), {
            {
                Text = "Discord Webhook",
                Color = Color3.fromRGB(3, 111, 252),
                Clicked = function()
                    answer = "Discord Webhook"
                end
            },
            {
                Text = "Save To File",
                Color = Color3.fromRGB(252, 144, 3),
                Clicked = function()
                    answer = "Save To File"
                end
            }
        })
        repeat
            task.wait()
        until answer

        if answer == "Discord Webhook" then
            local webhookUrl = modules.notification:InputBox("Webhook Url", "Discord Webhook Url Here")
            local webhookData = {
                embeds = {
                    {
                        title = "**Bloxburger** - Neighborhood Code Fetcher",
                        description = ("**Successfully fetched %s codes.**"):format(#codes),
                        color = 36863,
                        fields = { },
                        footer = {
                            text = "Bloxburger"
                        },
                        timestamp = DateTime.now():ToIsoDate(),
                        thumbnail = {
                            url = "https://bloxburger.eu/resc/Bloxburger.png"
                        }
                    }
                }
            }
            for index, code in next, codes do
                table.insert(webhookData.embeds[1].fields, {
                    name = ("Code %s"):format(index),
                    value = ("> *Code:* ``%s``\n> *Expiration:* ``%s``"):format(code.name, os.date("%B %A %dth, %Y %I%p", code.renew_time)),
                    inline = false
                })
            end
            httpRequest({
                Url = webhookUrl,
                Method = "POST",
                Headers = {
                    ["Content-Type"] = "application/json"
                },
                Body = jsonEncode(webhookData)
            })

            notification.sideNotify("Successfully requested the webhook to send the codes.")
        elseif answer == "Save To File" then
            local fileContent = [[
                ____  _           _                               
                |  _ \| |         | |                              
                | |_) | | _____  _| |__  _   _ _ __ __ _  ___ _ __ 
                |  _ <| |/ _ \ \/ / '_ \| | | | '__/ _` |/ _ \ '__|
                | |_) | | (_) >  <| |_) | |_| | | | (_| |  __/ |   
                |____/|_|\___/_/\_\_.__/ \__,_|_|  \__, |\___|_|   
                                                    __/ |          
                                                   |___/           
            ]]
            fileContent ..= "\n\n"
            for index, code in next, codes do
                fileContent ..= ("Code: %s\nExpiration: %s\n\n"):format(code.name, os.date("%B %A %dth, %Y %I%p", code.renew_time))
            end

            local randomNumber = math.random(11111111, 99999999)
            writefile(("yourexecutor/workspace/codes_%s.bb"):format(randomNumber), fileContent)

            notification.sideNotify(("Successfully wrote all codes to the file 'yourexecutor/workspace/codes_%s.bb'"):format(randomNumber))
        end
    end)
    ui.pages.neighborhood.sections.codeStealing:Toggle("Upload To Cloud", true, function(state)
        featureConfig.neighborhood.uploadToCloud = state
    end)
end

-- extra
do
    -- sections
    ui.pages.extra.sections = {
        ui = ui.pages.extra:Section("User Interface"),
        server = ui.pages.extra:Section("Server"),
        credits = ui.pages.extra:Section("Credits")
    }

    -- elements
    ui.pages.extra.sections.ui:DoubleLabel("UI Toggle Key", "Left Alt", Color3.fromRGB(155, 155, 155))
    ui.pages.extra.sections.ui:Colorpicker("UI Theme", libraries.ui:GetTheme(), function(newThemeColor)
        libraries.ui:SetTheme(newThemeColor)
    end)

    ui.pages.extra.sections.server:Button("Rejoin", function()
        notification.sideNotify("Attempting Rejoin ...")

        teleportService:Teleport(game.PlaceId, localPlayer)
    end)
    ui.pages.extra.sections.server:Button("Server Hop", function()
        notification.sideNotify("Attempting Server Hop ...")
        
        local allJobIds = {}
        local chosenJobId
        for _, server in next, jsonDecode(game:HttpGetAsync(("https://games.roblox.com/v1/games/%s/servers/Public?sortOrder=Asc&limit=100"):format(game.PlaceId))).data do
            if server.maxPlayers and server.playing and server.id then
                if type(server) == "table" and server.maxPlayers > server.playing and server.id ~= game.JobId then
                    table.insert(allJobIds, server.id)
                end
            end
        end
        if #allJobIds > 0 then
            chosenJobId = allJobIds[math.random(1, #allJobIds)]
        end

        if chosenJobId then
            teleportService:TeleportToPlaceInstance(game.PlaceId, chosenJobId)
        elseif not chosenJobId then
            notification.sideNotify("Error, couldn't find a server.")
        end
    end)

    ui.pages.extra.sections.credits:DoubleLabel("Script Founder & Leader", discordData.discord_username, Color3.fromRGB(150, 150, 150))
    ui.pages.extra.sections.credits:DoubleLabel("Discord Manager", discordData.server_manager, Color3.fromRGB(150, 150, 150))
    ui.pages.extra.sections.credits:Line()
    ui.pages.extra.sections.credits:Button("Copy Discord Invite", function()
        setclipboard(discordData.server_url)
        notification.sideNotify("Successfully copied the discord invite URL.")
    end)
end; if START_SCRIPT then game:HttpGet("/host/ui.lua"):LoadAs("UiLibrary"):ShowAsState("Premium_SCRIPT", "Visible", true, "Bloxburger") end;